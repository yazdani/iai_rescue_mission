;;; Copyright (c) 2016, Fereshta Yazdani <yazdani@cs.uni-bremen.de>
;;; All rights reserved.
;; 
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions are met:
;;; 
;;;     * Redistributions of source code must retain the above copyright
;;;       notice, this list of conditions and the following disclaimer.
;;;     * Redistributions in binary form must reproduce the above copyright
;;;       notice, this list of conditions and the following disclaimer in the
;;;       documentation and/or other materials provided with the distribution.
;;;     * Neither the name of the Institute for Artificial Intelligence/
;;;       Universitaet Bremen nor the names of its contributors may be used to 
;;;       endorse or promote products derived from this software without 
;;;       specific prior written permission.
;;; 
;;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;; POSSIBILITY OF SUCH DAMAGE.

(in-package :instruct-mission)


(defun create-mhri-msg (desiglist)
(format t "INSIDE CREAHE with desiglist : ~a~%" desiglist)
(let*((one (first desiglist))
      (boolmsg NIL)(errormsg NIL)(stringmsg NIL)
      (posemsg NIL)(internal NIL)(interpmsg NIL)(msg NIL))
  ;;(format t "Length desiglist : ~a~%" (length desiglist))
  (cond ((= (length desiglist) 0)
         (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                            :data 0))
         (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                          :data "Error: Why is the command empty?"))
         (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                               :value boolmsg
                                               :error errormsg
                                               :type ""
                                               :pose  (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
         (setf msg interpmsg))
        ((= (length desiglist) 1)
    ;;     (format t "ONE ACTION ~%")
         (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                            :data (first one)))
         (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                          :data (second one)))
         (setf stringmsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                        :data  (third one)))
     
         (cond((equal (fourth one) NIL)
               (setf posemsg (cl-transforms-stamped::to-msg(cl-transforms-stamped:pose-stamped->pose (cl-transforms-stamped:make-identity-pose)))))
              (t (setf internal (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth one))))
                 (setf posemsg (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal) 'WORLD_MISSION-SRV:SUM))))
         ;;(setf posemsg (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal) 'WORLD_MISSION-SRV:SUM))
         (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                               :value boolmsg
                                               :error errormsg
                                               :type stringmsg
                                               :pose posemsg))
         (setf msg (list interpmsg)))
	((= (length desiglist) 3)
	 (setf msg (three-lists desiglist)))
        ((= (length desiglist) 2)
      ;;  (format t "Length desiglist : ~a~%" desiglist)
        ;; (format t "array-msgs ~a~%" (second desiglist))
         (let*((one (first desiglist))
               (two (second  desiglist))
               (boolmsgb NIL)
               (errormsgb NIL)
               (stringmsgb NIL)
               (internal2 NIL)
               (posemsgb NIL)
               (interpmsgb NIL))
           (format t "OKAAISCH")
           (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                          :data (first one)))
           (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                           :data (second one)))
           (setf stringmsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                            :data  (third one)))
           (format t "TESTER1 ~a~%" one)
           (format t "TESTER2 ~a~%" two)
           (cond((equal (fourth one) NIL)
                 (setf posemsg (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
                (t (setf internal (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth one))))
                   (setf posemsg (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal) 'WORLD_MISSION-SRV:SUM))))
           (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                                 :value boolmsg
                                                 :error errormsg
                                                 :type stringmsg
                                                 :pose posemsg))
           (setf boolmsgb (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                           :data (first two)))
           (setf errormsgb (cl-transforms-stamped::make-msg "std_msgs/String"
                                                            :data (second two)))
           (setf stringmsgb (cl-transforms-stamped::make-msg "std_msgs/String"
                                                             :data  (third two)))
           (format t "BIN HIER ~a und ~a~%" (third one) (third two))
           (cond((and (or (string-equal (third one) "move")
                          (string-equal (third one) "scan"))
                      (string-equal (third two) "take-picture")
                      (equal (fourth two) NIL))
                 (setf posemsgb posemsg))
                ((and (string-equal (third one) "")
                      (string-equal (third two) "take-picture")
                       (equal (fourth two) NIL))
                 (format t "hello ~%")
                 (setf posemsgb (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
                ((and (string-equal (third two) "")
                      (not (string-equal (third two) "take-picture"))
                      (equal (fourth two) NIL))
                   (setf posemsgb (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
                (t (setf internal2 (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth two))))
                   (setf posemsgb (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal2) 'WORLD_MISSION-SRV:SUM))))
           (format t "WAR HIER~%")
           (setf interpmsgb (roslisp:make-message "mhri_msgs/interpretation"
                                                  :value boolmsgb
                                                  :error errormsgb
                                                  :type stringmsgb
                                                  :pose posemsgb))
           ;;     (format t "interpmsg ~a~%" interpmsg)
           ;;     (format t "interpmsgb ~a~%" interpmsgb)  
           (setf msg (list interpmsg interpmsgb)))))
  msg))

(defun three-lists (desiglist)
  (format t "inside three lists ~a~%" desiglist)
  (let*((one (first desiglist))
	(two (second  desiglist))
	(three (third desiglist))
	(boolmsga NIL)(boolmsgb NIL)(boolmsgc NIL)
	(errormsga NIL)(errormsgb NIL) (errormsgc NIL)
	(stringmsga NIL)(stringmsgb NIL)(stringmsgc NIL)
	(internal1 NIL)(internal2 NIL)(internal3 NIL)
	(posemsga NIL)(posemsgb NIL)(posemsgc NIL)(msg NIL)
	(interpmsga NIL)(interpmsgb NIL)(interpmsgc NIL))
    (setf boolmsga (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                    :data (first one)))
    (setf errormsga (cl-transforms-stamped::make-msg "std_msgs/String"
                                                     :data (second one)))
    (setf stringmsga (cl-transforms-stamped::make-msg "std_msgs/String"
                                                      :data  (third one)))
    (cond((equal (fourth one) NIL)
          (setf posemsga (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
         (t (setf internal1 (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth one))))
                   (setf posemsga (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal1) 'WORLD_MISSION-SRV:SUM))))
    (setf interpmsga (roslisp:make-message "mhri_msgs/interpretation"
                                           :value boolmsga
                                           :error errormsga
                                           :type stringmsga
                                           :pose posemsga))
    (setf boolmsgb (cl-transforms-stamped::make-msg "std_msgs/Bool"
						    :data (first two)))
    (setf errormsgb (cl-transforms-stamped::make-msg "std_msgs/String"
						     :data (second two)))
    (setf stringmsgb (cl-transforms-stamped::make-msg "std_msgs/String"
						      :data  (third two)))
   (cond((and (or (string-equal (third one) "move")
                  (string-equal (third one) "scan"))
              (string-equal (third two) "take-picture"))
         (setf posemsgb posemsga))
        ((and (not (string-equal (third one) ""))
              (string-equal (third two) "take-picture"))
         (setf posemsgb (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
        ((and (string-equal (third two) "")
              (not (string-equal (third two) "take-picture"))
                      (equal (fourth two) NIL))
                   (setf posemsgb (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
          (t (setf internal2 (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth two))))
             (setf posemsgb (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal2) 'WORLD_MISSION-SRV:SUM))))
    (setf interpmsgb (roslisp:make-message "mhri_msgs/interpretation"
                                                  :value boolmsgb
                                                  :error errormsgb
                                                  :type stringmsgb
                                                  :pose posemsgb))
    (setf boolmsgc (cl-transforms-stamped::make-msg "std_msgs/Bool"
						    :data (first three)))
    (setf errormsgc (cl-transforms-stamped::make-msg "std_msgs/String"
						     :data (second three)))
    (setf stringmsgc (cl-transforms-stamped::make-msg "std_msgs/String"
						      :data  (third three)))
    (format t "SHOW ME LISTE (third one) ~a~% (third two) ~a~% (third three) ~a --> ~a~%" (third one) (third two) (third three) (and (string-equal (third two) (third one))))
    (cond((and (or (and (string-equal (third two) "move")
                        (string-equal (third one) "scan"))
                   (and (string-equal (third one) "move")
                        (string-equal (third two) "scan"))
                   (string-equal (third two) (third one))
                   (and (not(string-equal (third two) ""))
                        (string-equal (third one) "")))
               (string-equal (third three) "take-picture"))
          (format t "HAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAinside this function~%")
          (setf posemsgc posemsgb))
         ((and (string-equal (third two) "")
               (not (string-equal (third one) ""))
               (string-equal (third three) "take-picture"))
          (format t "HAAAAAAAAAAAAB ICH GEMACHT~%")
          (setf posemsgc posemsga))
         ((and (not (string-equal (third three) "take-picture"))
               (equal (fourth three) NIL))
          (setf posemsgc (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
         (t (setf internal3 (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth three))))
            (setf posemsgc (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal3) 'WORLD_MISSION-SRV:SUM))))
    (format t "WAUAS~%")
    (setf interpmsgc (roslisp:make-message "mhri_msgs/interpretation"
                                                  :value boolmsgc
                                                  :error errormsgc
                                                  :type stringmsgc
                                                  :pose posemsgc))
        (setf msg (list interpmsga interpmsgb interpmsgc))
    msg))
         
(defun create-the-msg (agent type icmd gelem)
 (format t "agent ~a~%" agent)
;;  (format t "type ~a~%" type)
;;  (format t "OK: icmd ~a~%" icmd)
  (let*((uno NIL)(sec NIL)(desig2 NIL)(desig3 NIL)
        (acts (split-sequence:split-sequence #\; icmd))
        (bracket (split-sequence:split-sequence #\= icmd))
        (desig NIL))
    (format t "OK2: icmd ~a~%" icmd)
    (format t "(length acts) ~a and length bracket ~a~%" (length acts) (length bracket))
    (cond ((and (= (length acts) 1)
		( = (length bracket) 1))
	   (format t "one acton ~%")
           (setf desig (list (create-msg-one-action agent icmd gelem))))
	  ((and ( = (length bracket) 2)
		( = (length acts) 1))
	   (format t "bracket ~a~%" (length bracket))
           (setf desig (create-msg-one-action agent icmd gelem)))
          ((and (= (length acts) 2)
		(= (length bracket) 1))
	   (format t "two actions ~%")
           (setf desig (create-msg-two-actions agent type icmd gelem)))
	  ((and (= (length bracket) 2)
          (= (length acts) 2))
	   (format t " acts ~a~% and bracket ~a~%" acts bracket)
	   (setf uno (remove #\( (first acts) :start 0 :end 1))
     (setf sec (format NIL "~a)" (remove #\) (second acts) :start 0)))
	   (format t "unoi ~a~% und sec ~a~%" uno sec)
	   (setf desig2 (list (create-msg-one-action agent uno  gelem)))
	   (format t "desg2 ~a~%" desig2)
	   (setf desig3 (list (create-msg-one-action agent sec gelem)))
	   (format t " desig2 ~a~% and desig3 ~a~%" desig2 desig3)
     (cond ((= (length desig2) 2)
            (setf desig (append desig2 desig3)))
            ((= (length desig2) 1)
             (cond((= (length (car desig2)) 4)
                   (setf desig (append desig2 desig3)))
                  ((= (length (car desig2)) 2)
                (setf desig (append (car desig2) desig3)))
                  )))))
    (format t "WAS IS DEASIG ~a~%" desig)
    (format t "(length acts) ~a~%" (length desig2))
    (format t "(length acts2) ~a~%" (length (car desig2)))
    desig))

(defun create-msg-one-action (agent icmd gelem)
 (format t "inside create-msg-one-action~%")
  (let*((ins (split-sequence:split-sequence #\= icmd))
        (desig NIL))
  ;;  (format t "length ins ~a~%" (length ins))
    (cond ((= (length ins) 1)
	   (format t "create-msg-one-action~%")
           (setf desig (create-msg->action icmd gelem agent)))
          ((> (length ins) 1)
	   (format t "create-msg-one-actions~%")
           (setf desig (create-msg->ins-actions icmd gelem))));; agent))))
     desig))

(defun create-msg-two-actions (agent type icmd gelem)
  ;; (format t "inside create-msg-two-actions ~a~%" icmd)
  (let*((splitter (split-sequence:split-sequence #\; icmd))
        (desig1 (create-the-msg agent type (first splitter) gelem))
        (desig2 (create-the-msg agent type (second splitter) gelem))
        (desig NIL))
    (format t "----------->desig1 ~a~% desig2 ~a~%" desig1 desig2)
    (setf desig (append desig1 desig2))
  ;;      (format t "233432<----------->desig1 ~a~% desig2 ~a~%" desig1 desig2)
  ;;  (cond ((and (equal (first (car desig1)) 0)
  ;;              (equal (first (car desig2)) 0))
  ;;         (format t "1111111111----------->desig1 ~a~% desig2 ~a~%" desig1 desig2)
  ;;         (setf desig (append desig1 desig2)))
  ;;        ((equal (first (car desig1)) 0)
  ;;         (format t "2222222222222----------->desig1 ~a~% desig2 ~a~%" desig1 desig2)
  ;;         (setf desig desig1))
  ;;        ((equal (first (car desig2)) 0)
  ;;         (format t "33333333333----------->desig1 ~a~% desig2 ~a~%" desig1 desig2)
  ;;         (setf desig desig2))
  ;;        (t;;(format t "4444444444----------->desig1 ~a~% desig2 ~a~%" desig1 desig2)
  ;;         (setf desig (append desig1 desig2))))
  ;;  (format t "TWO ACTIONS ~a~%" desig)
  desig))

;;#######################################################################################;;
;;                                                                                       ;;
;;      CREATE-MSG->INS-ACTIONS => action(direction,object)<=inside(direction,object)    ;;
;;                                                                                       ;;
;;#######################################################################################;;

(defun create-msg->ins-actions (cmd gelem);; agent)
  (let*((action (first (split-sequence:split-sequence #\( cmd)))
        (desig NIL))
    (cond ((string-equal action "move")
	   (format t "move is working~%")
           (setf desig (action-move-ins cmd gelem)));; agent)))
          ((string-equal action "take")
	   (format t "inside take~%")
           (setf desig (action-take-ins cmd gelem)));; agent)))
          ((string-equal action "scan")
           (setf desig (action-scan-ins cmd gelem)))
          (t (format t "Could not parse this sentence, because command is not of types: move, take or scan~%")))
(format t "create-msg->ins desig ~a~%" desig)
    desig))


(defun action-move-ins (cmd gelem)
(format t "action-mve-ins~%")
(let*((cmd-split (split-sequence:split-sequence #\= cmd))
      (cmd-splitter1 (split-sequence:split-sequence #\( (first cmd-split))) 
      (cmd-splitter1-1 (split-sequence:split-sequence #\, (second cmd-splitter1))) ;;wenn move(right,wood) >= then 2 otherwise 1 <= move(wood)
      (cmd-splitter2 (split-sequence:split-sequence #\( (second cmd-split)))
      (desig NIL))
  (cond((and (= (length cmd-splitter1) 2) ;;move(wood)
             (= (length cmd-splitter2) 2);;inside(right,wood)
             (= (length cmd-splitter1-1) 1)) ;;move(wood)
        (setf desig (one-by-two cmd-splitter1 cmd-splitter2)));; cmd-splitter1-1)))
       ((and (= (length cmd-splitter1) 2) ;;move(right,wood)
             (= (length cmd-splitter2) 2) ;;inside(right,wood)
             (= (length cmd-splitter1-1) 2)) ;;move(right,wood)
        (setf desig (two-by-two cmd-splitter1 cmd-splitter2)))
         ((and (= (length cmd-splitter1) 2) ;;move(right,wood)
             (= (length cmd-splitter2) 3) ;;inside(right,wood)
             (= (length cmd-splitter1-1) 2)) ;;move(right,wood)
          (setf desig (two-by-two-point cmd-splitter1 cmd-splitter2 gelem)))
       ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
             (not (equal NIL gelem))
             (= (length cmd-splitter2) 2) ;;inside(right,wood))
             (= (length cmd-splitter1-1) 1));; move(pointed(wood)
        (setf desig (one-point-by-two cmd-splitter1 cmd-splitter2 gelem)))
       ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
             (equal NIL gelem)
             (= (length cmd-splitter2) 2) ;;inside(right,wood))
             (= (length cmd-splitter1-1) 1));; move(pointed(wood)
        (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL)))
         ((and (= (length cmd-splitter1) 2) ;;move(wood)
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (not (equal NIL gelem))
               (= (length cmd-splitter1-1) 1)) ;;move(wood)
          (setf desig (one-by-two-point cmd-splitter1 cmd-splitter2 gelem)))   
         ((and (= (length cmd-splitter1) 2) ;;move(wood)
               (equal NIL gelem)
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (= (length cmd-splitter1-1) 1)) ;;move(wood)
          (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL))) 
         ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
               (not (equal NIL gelem))
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (= (length cmd-splitter1-1) 1)) ;;move(pointed(wood))
           (setf desig (one-point-by-two-point cmd-splitter1 cmd-splitter2 gelem)))
         ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
               (equal NIL gelem))
              ;; (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
              ;; (= (length cmd-splitter1-1) 1)) ;;move(pointed(wood))
          (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL))) 
           ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                 (not (equal NIL gelem))
                 (= (length cmd-splitter2) 2) ;;inside(right,wood)
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
            (setf desig (two-point-by-two cmd-splitter1 cmd-splitter2 gelem)))
             ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                   (equal NIL gelem)
                   (= (length cmd-splitter2) 2) ;;move(right,wood)
                   (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
           (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL)))
           ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood)
                (not (equal NIL gelem))
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
            (setf desig (two-point-by-two-point cmd-splitter1 cmd-splitter2 gelem)))
            ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood)
                (equal NIL gelem)
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
             (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL)))
             (t (format t "Something went wrong in the interpretation action-move-ins~%")
                (setf desig (list 0 (format NIL "Error: Something went wrong during the interpetation, please repeat your instruction") "" NIL))))
(format t "END OF FUNCTION desig ~a~%" desig)
  desig)) 


;; NO METHOD WITH POINTING GESTURE KEEP IN MIND!
;; COMMAND SCAN HAS TO BE CORRECTED
(defun action-scan-ins (cmd gelem)
  (format t "action-scan-ins~%")
(let*((cmd-split (split-sequence:split-sequence #\= cmd))
      (word (first (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( cmd)))))
      (br (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\( cmd)))))
      (t-list (instruct-mission::swm->type->amount-elems br))  
      (cmd-counts (split-sequence:split-sequence #\( (second cmd-split)))
      (dir (first (split-sequence:split-sequence #\, (second cmd-counts))))
      (elem (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-counts))))))
      (desig NIL)(ref1 NIL)(ref2 NIL)
      (elem-list (instruct-mission::swm->type->amount-elems elem))
      (desig-intern1 NIL)(desig-intern NIL)(desig-intern2 NIL) (type (instruct-mission::swm->elem-name->type gelem))
      (ref NIL))
  (format t "woooord ~a~%" word)
      (cond((and (= 2 (length cmd-counts))
                 (= (length elem-list) 1)
                 (= (length t-list) 1))
            (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car t-list))))))
            (setf ref1 (reference desig-intern1))
            (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
           (setf ref (reference desig-intern2))
            (setf desig (list (list 1 "" "scan" ref1)
                              (list 1 "" "scan" ref))))
           ((and (= 2 (length cmd-counts))
                 (= (length elem-list) 1)
                 (= (length t-list) 0))
            (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
           (setf ref (reference desig-intern2))
           (setf desig (list (list 0 (format NIL "Error: No object of type '~a' available inside the map" br) "" NIL)
                             (list 1 "" "scan" ref))))
           ((and (= 2 (length cmd-counts))
                 (= (length elem-list) 0)
                   (= (length t-list) 0))
            (setf desig (list (list 0 (format NIL "Error: There are no objects of type '~a' and '~a' inside the map!" br elem) "" NIL))))
           ((and (= 2 (length cmd-counts))
                 (= (length elem-list) 0)
                   (= (length t-list) 1))
              (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car t-list))))))
            (setf ref1 (reference desig-intern1))
            (setf desig (list (list 1 "" "scan" ref1)
                         (list 0 (format NIL "Error: There is no object of type '~a' inside the map!" elem) "" NIL))))
           ((and (= 2 (length cmd-counts))
                 (> (length elem-list) 1))
            (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem)))))
            (setf ref (reference desig-intern))
            (setf desig (list 1 "" "scan" ref)))
           ;; (setf desig (list "false" (format NIL "Error: There are too many objects of type '~a' inside the map!" elem) "" NIL)))
           ((and (= 3 (length cmd-counts)))
            (setf desig (action-scan-ins-pointer cmd gelem)))
           (t (format t "Something went wrong in the function action-scan-ins~%")
              (setf desig (list (list 0 (format NIL "Error: Something went wrong with the interpretation of the instruction!") "" NIL)))))
  desig))


(defun action-scan-ins-pointer (cmd gelem)
;;  (format t "action-scan-ins-pointer~%")
   (let*((cmd-split (split-sequence:split-sequence #\= cmd))
         (cmd-counts (split-sequence:split-sequence #\( (second cmd-split)))
         (dir (first (split-sequence:split-sequence #\,  (second cmd-counts))))
         (elem (first (split-sequence:split-sequence #\)  (third cmd-counts))))
         (desig NIL)
         (elem-list (instruct-mission::swm->type->amount-elems elem))
         (type (instruct-mission::swm->elem-name->type gelem))
         (desig-intern NIL)
         (ref NIL))
     (cond((string-equal elem type)
           (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
          (setf ref (reference desig-intern))
           (setf desig (list 1 "" "scan" ref)))
          ((and (not(string-equal elem type))
                (/= (length elem-list) 0))
           (setf desig (list 0 (format NIL "Error: Pointed object ~a and command ~a are not fitting together" type elem) "" NIL )))
          ((and (not(string-equal elem type))
                (= (length elem-list) 0))
           (setf desig (list 0 (format NIL "Error: There is no object of type '~a' in the map!" elem) "" NIL )))
          (t (format t "Something went wrong during the interpretation in action-scan-ins-pointer")
             (setf desig (list 0 "false" (format NIL "Something went wrong during the command interpretation!") "" NIL))))
     (list desig)))
            
(defun action-take-ins (cmd gelem)
(let*((cmd-splitter (split-sequence:split-sequence #\= cmd))
      (cmd-splitter2 (split-sequence:split-sequence #\( (second cmd-splitter)))
                      (dir (first (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( (second cmd-splitter))))))
      (elem (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( (second cmd-splitter))))))))
      (elem-list (instruct-mission::swm->type->amount-elems elem))
      (desig NIL)
      (desig-intern NIL)
      (ref NIL))
(cond((and (= (length cmd-splitter2) 2)
           (= (length elem-list) 1))
      (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
      (setf ref (reference desig-intern))
      (setf desig (list 1 "" "take-picture" ref)))
     ((and (= (length cmd-splitter2) 2)
           (> (length elem-list) 1))
      (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem)))))
      (setf ref (reference desig-intern))
      (setf desig (list 1 "" "take-picture" ref)))
      ;;  (setf desig (list "false" (format NIL "Error: There are too many objects of type '~a'!" elem) "" NIL)))
      ((and (= (length cmd-splitter2) 2)
           (< (length elem-list) 1))
        (setf desig (list 0 (format NIL "Error: No object of type '~a' available!" elem) "" NIL)))
      ((= (length cmd-splitter2) 3)
       (setf desig (action-take-ins-pointer cmd gelem)))
      (t (format t "Something went wrong with the interpretations inside action-take-ins~%")
         (setf desig (list 0 (format NIL "Error: Could not interpret the command, not available in the vocabulary") "" NIL))))
desig))

(defun action-take-ins-pointer (cmd gelem)
(let*((cmd-splitter (split-sequence:split-sequence #\= cmd))
      (cmd-split (split-sequence:split-sequence #\(  (second cmd-splitter)))
      (elem (first (split-sequence:split-sequence #\) (third cmd-split))))
      (dir (first (split-sequence:split-sequence #\, (second cmd-split))))
      (type (instruct-mission::swm->elem-name->type gelem))
      (desig NIL)
      (desig-intern NIL)
      (ref NIL)
      (elem-list (swm->type->amount-elems elem)))
  (cond((string-equal type elem)
        (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
       (setf ref (reference desig-intern))
        (setf desig (list 1 "" "take-picture" ref)))
       ((and (not (string-equal type elem))
             (> (length elem-list) 0))
        (setf desig (list 0 (format NIL "Error: Pointed object '~a' and nl command '~a' are not the same!" type elem) "" NIL)))
        ((and (not (string-equal type elem))
             (= (length elem-list) 0))
        (setf desig (list 0 (format NIL "Error: Object in the command '~a' are not in the map!" elem) "" NIL)))
        (t (format t "Something went wrong during the interpretation in action-take-ins-pointer~%")
           (setf desig (list 0 (format NIL "Error: Could not interpret the instruction. Something is wrong.") "" NIL))))
  desig))
  


;;#######################################################################################;;
;;                                                                                       ;;
;;        CREATE-MSG-ONE-ACTION => action(direction,object) vs. action(object)           ;;
;;                                                                                       ;;
;;#######################################################################################;;

(defun create-msg->action (icmd gelem agent)
  (format t "create-msg->action~%")
  (let*((act (first (split-sequence:split-sequence #\( icmd)))
        (desig NIL))
    (cond ((string-equal act "move")
           (setf desig (action-move icmd gelem)))
          ((string-equal act "take")
           (setf desig (action-take icmd gelem)))   ;;done
          ((string-equal act "scan")
           (setf desig (action-scan icmd gelem agent))) ;; done
	  ((string-equal act "come")
	   (setf desig (action-come icmd))) ;; done
          (t (format t "cmd is not of types: 'move', 'take', 'scan' and 'come'~%")
             (setf desig (list 0 (format NIL "The command couldn't be interpreted, maybe it's empty") "" NIL))))
    desig))


(defun action-come (cmd)
  (let*((fbrakets (split-sequence:split-sequence #\( cmd))
;;	(act (first fbrakets))
        (sbrakets (first (split-sequence:split-sequence #\) (second fbrakets))))
        (pose (swm->get-cartesian-pose-agent "genius"))
        (desig-intern NIL)
        (ref NIL)
        (desig NIL))
  ;;  (format t "ACTION COME~%")
    (cond ((string-equal sbrakets "back")
           (setf desig-intern (make-designator :location `((:toMe ,pose ))))
           (setf ref (reference desig-intern))
	   (setf desig (list 1 "" "move" ref)))
	  (t (format t "Something went wrong inside 'action-come'~%")
	     (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation of '~a'" cmd) "" NIL))))
    desig))
	   

;;move(wood)
;;move(pointed_at(wood))
(defun action-move (cmd gelem)
  ;;(format t "action move ~%")
  (let*((len (split-sequence:split-sequence #\, cmd))
        (fbrakets (split-sequence:split-sequence #\( cmd))
        (elem (first (split-sequence:split-sequence #\) (second fbrakets))))
        (pelem (first (split-sequence:split-sequence #\) (third fbrakets))))
        (type (instruct-mission::swm->elem-name->type gelem))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (elem-list (instruct-mission::swm->type->amount-elems elem)) ;;move(wood)
        (pelem-list (instruct-mission::swm->type->amount-elems pelem))) ;;move(pointed_at(wood))
    (cond ((and (= (length len) 1)
                (= (length fbrakets) 2)  ;;move(wood)
                (= (length elem-list) 1)) 
           (setf desig-intern (make-designator :location `((:close ,(first (car elem-list))))))
          (setf ref (reference desig-intern))
  ;;         (format t "action-move~%")
           (setf desig (list 1 "" "move" ref)))
          ((and (= (length len) 1)
                (= (length fbrakets) 2)  ;;come(back)
                (string-equal elem "back")) 
           (setf desig (action-come cmd)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 2)  ;;move(wood) to many elements TODO: move(river)
                 (> (length elem-list) 1))
            (setf desig-intern (make-designator :location `((:close ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem)))))          
           ;; (setf desig (list "false" (format NIL "Error: There are too many objects in the world with the name '~a'" elem) "" NIL)))
            (setf ref (reference desig-intern))
            (setf desig (list 1 "" "move" ref)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 2)  ;;move(wood) no elements
                 (< (length elem-list) 1))
            (setf desig (list 0 (format NIL "Error: There are no objects in the world with the name '~a'" elem) "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements fits move(pointed_at(wood))
                 (not (equal gelem NIL))
                 (string-equal type pelem))
            (setf desig-intern (make-designator :location `((:close ,gelem))))
            (setf ref (reference desig-intern))
            (setf desig (list 1 "" "move" ref)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (not (string-equal type pelem))
                 (equal NIL gelem)
                 (> (length pelem-list) 0))
            (setf desig (list 0 (format NIL "Error: Not possible to recognize the pointed Object") "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (not (string-equal type pelem))
                 (not (equal NIL gelem))
                 (> (length pelem-list) 0))
            (setf desig (list "false" (format NIL "Error: Pointed Object '~a' do not fit with nl command '~a'" type pelem) "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (not (string-equal type pelem))
                 (= (length pelem-list) 0))
            (setf desig (list 0 (format NIL "Error: Pointed Object '~a' do not fit with nl command '~a' and is maybe not available in the map" type pelem) "" NIL)))
           ((and (= (length len) 2)
                 (= (length fbrakets) 3))
            (setf desig (action-move-gesture cmd gelem)))
           ((and (= (length len) 2)
                 (= (length fbrakets) 2))
            (setf desig (action-move-two cmd)))
           (t (format t "Something went wrong inside 'action-move'~%")
              (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation of '~a'" cmd) "" NIL))))
    desig))


;;move(dir,object)
(defun action-move-two (cmd)
  (let*((dir (first (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( cmd)))))
        (desig-intern NIL)
        (desig NIL)
        (ref NIL)
        (elem1  (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( cmd)))))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1)))
    (cond((= (length elem1-list) 1)
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem1-list))))))
    ;;      (format t "desig-intern ~a~%" desig-intern)
          (setf ref (reference desig-intern))
          (setf desig (list 1 "" "move" ref)))
         ((= (length elem1-list) 0)
          (setf desig (list 0 (format NIL "Error: ~a can not be found in the world" elem1) "" NIL)))
          ((> (length elem1-list) 1)
           (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
           (setf ref (reference desig-intern))
           (setf desig (list 1 "" "move" ref)))
          ;; (setf desig (list "false" (format NIL "Error: More objects of type ~a can be found in the world" elem1) "" NIL)))
          (t (format t "Something is going wrong, the interpretation did not work correctly~%")
             (setf desig (list 0 (format NIL "Error: Interpretation did not work, please repeat the command or look closer into the code") "" NIL))))
    desig))

;;move(dir,pointed_at(test))
(defun action-move-gesture (cmd gelem)
(let*((dir (second (split-sequence:split-sequence #\( (first (split-sequence:split-sequence #\, cmd)))))
      (desig NIL)
      (desig-intern)
      (ref NIL)
      (word (first (split-sequence:split-sequence #\) (second(split-sequence:split-sequence #\( (second (split-sequence:split-sequence #\, cmd)))))))
      (word-list (instruct-mission::swm->type->amount-elems word))
      (type (instruct-mission::swm->elem-name->type gelem)))
  ;;(format t " what is word ~a~%" word)
  (cond ((and (string-equal word type))
         (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
         (setf ref (reference desig-intern))
         (setf desig (list 1 "" "move" ref)))
        ((and (not (string-equal word type))
              (> (length word-list) 0)
              (not (equal gelem NIL)))
         (setf desig (list 0 (format NIL "Error: You are pointing towards a '~a' but you say  '~a', please correct your command!" type word )"" NIL)))
        ((and (not (string-equal word type))
              (> (length word-list) 0)
               (equal gelem NIL))
         (setf desig (list 0 (format NIL "Error: Pointing gesture not recognized, please point again!")"" NIL)))
        ((and (not (string-equal word type))
              (= 0 (length word-list)))
         (setf desig (list 0 (format NIL "Error: You are pointing towards a '~a' but you say  '~a', the '~a' is maybe not available inside the map. Please correct your command!" type word word)"" NIL)))
        (t (format t "Something went wrong inside 'action-move-gesture'~%")
           (setf desig (list 0 (format NIL "Error: Something went wrong with the interpretation of the command '~a'!" cmd) "" nil))))
  desig))

;;what we already did:
;;scan(area)/scan(pointed_at(wood)) <= area:agents-pose
;;take(picture) <=agents-pose


;;take a picture at the position of the agent
;;take(picture)
(defun action-take (cmd gelem)
  (format t "action-take~%")
  (let*((splitter (split-sequence:split-sequence #\, cmd))
       (brackets (split-sequence:split-sequence #\( cmd))
       (type (instruct-mission::swm->elem-name->type gelem))
       (elem1 (first (split-sequence:split-sequence #\) (first (last splitter)))))
        (elem1-1 (second (split-sequence:split-sequence #\( elem1)))
       (elem1-list (instruct-mission::swm->type->amount-elems elem1))
       (desig NIL)(desig-intern NIL) (ref NIL))
    (format t " go into conditions ~%")
(cond ((and (= (length splitter) 1)
	    (= (length brackets) 2)) ;;take(picture)
       (format t "take picture~%")
       (setf desig (list 1 "" "take-picture" NIL)))
      ((and (= (length splitter) 2)
            (= (length brackets) 2)
            (= (length elem1-list) 1));;take(picture,tree)
       (setf desig-intern (make-designator :location `((:next ,(first (car elem1-list))))))
       (setf ref (reference desig-intern))
       (setf desig (list 1 "" "take-picture" ref)))
      ((and (= (length splitter) 2)
            (= (length brackets) 2)
            (> (length elem1-list) 1));;take(picture,tree) more trees
       (setf desig-intern (make-designator :location `((:next ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))))))
      ((and (= (length splitter) 2)
            (= (length brackets) 2)
            (not (equal gelem ""))
            (not (equal gelem NIL))
            (< (length elem1-list) 1));;take(picture,tree) more trees
       (setf desig (list 0 (format NIL "Error: There exist no elements of type '~a' in the world" elem1) "" NIL)))
      ((and (not (equal gelem NIL))
            (not (equal gelem "")))
       (cond((and (= (length splitter) 2)
                  (= (length brackets) 3)
                  (string-equal type elem1-1)) ;;take(picture,pointed_at(tree))
       (setf desig-intern (make-designator :location `((:next ,gelem))))
       (setf ref (reference desig-intern))
       (setf desig (list 1 "" "take-picture" ref)))
            ((and (= (length splitter) 2)
                  (= (length brackets) 3)
                   (not (equal gelem ""))
                   (not (equal gelem NIL))
                  (not (string-equal type elem1-1))) ;;take(picture,pointed_at(tree))
             (setf desig (list 0 (format NIL "Error: Pointed object '~a' is not a '~a'" type elem1-1) "" NIL)))))
      ((or (equal gelem NIL)
           (equal gelem ""))
       (format t "pointing gesture in action-take is not available~%")
       (setf desig (list 0 "Error: Could not read the pointing gesture, please repeat it" "" NIL)))           
       (t (format t "Something went wrong")
	  (setf desig (list 0 "Error: Something went wrong during command interpretation of 'take-picture'" "" NIL))))
      desig))

 


;;scan((test))
;;scan(area) <- means wasps
(defun action-scan (icmd gelem agent)
 ;; (format t "action-scan~%")
  (let*((test-jumper (split-sequence:split-sequence #\, icmd))
        (len (split-sequence:split-sequence #\_ icmd))
        (br (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\( icmd)))))
        (desig NIL)
        (type (instruct-mission::swm->elem-name->type gelem))
        (t-list (instruct-mission::swm->type->amount-elems br)))
    (cond ((and (= (length test-jumper) 1)
                (= (length len) 1))
           (cond((string-equal "area" br)
                 (setf desig (list 1 "" "scan" (instruct-mission::swm->get-cartesian-pose-agent agent))))
                ((= (length t-list) 1)
                 (setf desig-intern2 (make-designator :location `((:around ,(first (first t-list))))))
                 (setf ref1 (reference desig-intern2))                 
                 (setf desig (list 1 "" "scan" ref1)))
                ((> (length t-list) 1)
                 (setf desig-intern2 (make-designator :location `((:around ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") br)))))
                 (setf ref1 (reference desig-intern2))                 
                 (setf desig (list 1 "" "scan" ref1)))
                ((and (= (length len) 1)
                      (= (length t-list) 0))
                 (setf desig (list 0 (format NIL "Error: No objects are available of type '~a'" br) "" NIL)))
                (t (format t "Something went wrong during command interpretation~%")
                   (setf desig (list 0 "Error: Something went wrong during interpretation, please repeat" "" NIL)))))
           ((and (= (length len) 2)
                 (= (length test-jumper) 1))
            (setf desig (action-scan-with-gesture icmd gelem)))
           ((= (length test-jumper) 2)
            (setf desig (action-scan-two icmd gelem agent)))
           (t (format t "Something went wrong during command interpretation~%")
              (setf desig (list 0 "Error: Something went wrong during interpretation, please repeat" "" NIL))))
           
      ;;  (setf desig (action-scan-two icmd gelem agent)))
    desig))

;;scan(right,house)
(defun action-scan-two (icmd gelem agent)
 ;; (format t "action-scan-two~%")
  (let*((all (split-sequence:split-sequence #\, icmd))
        (len (split-sequence:split-sequence #\_ icmd))
        (br (first (split-sequence:split-sequence #\) (second all))))
        (dir (second (split-sequence:split-sequence #\( (first all))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (t-list (instruct-mission::swm->type->amount-elems br)))
  ;;  (format t "t-list ~a~%" t-list)
    (cond((and (= (length len) 1) 
               (string-equal "area" br))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(instruct-mission::swm->get-geopose-agent agent)))))
          (setf ref (reference desig-intern))
          (setf desig (list 1 "" "scan" ref)))
         ((and (= (length len) 1) 
               (= (length t-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car t-list))))))
          (setf ref (reference desig-intern))
          (setf desig (list 1 "" "scan" ref)))
         ((and (= (length len) 1) 
               (> (length t-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") br)))))
          (setf ref (reference desig-intern))
          (setf desig (list 1 "" "scan" ref)))
         ((and (= (length len) 1)
               (= (length t-list) 0))
          (setf desig (list 0 (format NIL "Error: No objects are available of type '~a'" br) "" NIL)))
         ((= (length len) 2)
          (setf desig (action-scan-with-gesture icmd gelem)))
         (t (format t "Something went wrong during command interpretation~%")
                (setf desig (list 0 "Error: Something went wrong during interpretation of '~a'" icmd))))
    desig))

;;scan(pointed_at(test))
(defun action-scan-with-gesture (cmd gelem)
  ;;(format t "action-scan-with-gesture~%")
  (let*((test-jumper (split-sequence:split-sequence #\, cmd))
      (elm (first (split-sequence:split-sequence #\) (third (split-sequence:split-sequence #\( cmd)))))
      (t-list (instruct-mission::swm->type->amount-elems elm))
      (n-gelem (instruct-mission::swm->elem-name->type gelem))
      (desig NIL))
    (if (= (length test-jumper) 1)
        (cond ((and (= (length t-list) 1)
                    (string-equal n-gelem elm))
               (setf desig (list 1 "" "scan" (instruct-mission::swm->elem-name->position gelem))))
              ((and (= (length t-list) 1)
                    (not(string-equal n-gelem elm))
                    (string-equal elm (second (first t-list))))
               (setf desig (list 0 (format NIL "Error: Pointed object of type '~a' is not a '~a'. Please correct your command." n-gelem elm) "" NIL)))
              ((and (=  (length t-list) 1)
                    (not (string-equal elm (second (first t-list)))))
               (setf desig (list 0 (format NIL "Error: '~a' is not inside the map" elm))))
             ;; ((> (length t-list) 1)
             ;;  (setf desig (list "false" (format NIL "Error: Two many elements in that list of type '~a'" elm) "" NIL)))
              ((= (length t-list) 0)
               (setf desig (list 0 (format NIL "Error: No object of type '~a' found in the world. Please correct your command." elm) "" NIL)))
              (t (format t "Something went wrong in 'action-scan-with-gesture'~%")
                 (setf desig (list 0 (format NIL "Error: Something went wrong with command '~a'" cmd) "" NIL))))
        (setf desig (action-scan-with-gesture-two cmd gelem)))
  desig))               

(defun action-scan-with-gesture-two (cmd gelem)
  ;;(format t "action-scan-with-gesture-two~%")
(let*((all (split-sequence:split-sequence #\, cmd))
     (dir (second (split-sequence:split-sequence #\( (first all))))
      (selm (second (split-sequence:split-sequence #\( (first (split-sequence:split-sequence #\) (second all))))))
      (t-list (instruct-mission::swm->type->amount-elems selm))
      (n-gelem (instruct-mission::swm->elem-name->type gelem))
      (desig NIL)
      (desig-intern NIL)
      (ref NIL))
  (cond ((and (= (length t-list) 1)
              (string-equal n-gelem selm))
         (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
         (setf ref (reference desig-intern))
         (setf desig (list 1 "" "scan" ref)))
        ((and (= (length t-list) 1)
              (not(string-equal n-gelem selm))
              (string-equal selm (second (first t-list))))
         (setf desig (list 0 (format NIL "Error: Pointed object of type '~a' is not a '~a'. Please correct your command." n-gelem selm) "" NIL)))
        ((and (=  (length t-list) 1)
              (not (string-equal selm (second (first t-list)))))
              (setf desig (list 0 (format NIL "Error: '~a' is not inside the map" selm))))
     ;;   ((> (length t-list) 1)
     ;;    (setf desig (list "false" (format NIL "Error: Two many elements in that list of type '~a'" selm) "" NIL)))
        ((= (length t-list) 0)
         (setf desig (list 0 (format NIL "Error: No object of type '~a' found in the world. Please correct your command." selm) "" NIL)))
        (t (format t "Something went wrong in 'action-scan-with-gesture'~%")
         (setf desig (list 0 (format NIL "Error: Something went wrong with command '~a'" cmd) "" NIL))))
  desig)) 

;;##############################################################################;;
;;                                                                              ;;
;;                   Helping-Hands for parsing the instructions                 ;;
;;                                                                              ;;
;;##############################################################################;;


(defun swm->type->amount-elems (type)
  (let*((liste (instruct-mission::swm->geopose-elements))
        (new-liste NIL))
    (loop for index from 0 to (- (length liste) 1)
          do (cond((and (string-equal (second (nth index liste)) type)
                       (equal new-liste NIL))
                  (setf new-liste (append (list (nth index liste)) new-liste)))
                 (t ())))
    new-liste))


(defun swm->map-type->name (type)
  (let*((liste (instruct-mission::swm->geopose-elements))
        (pnom NIL))
    (loop for i from 0 to (- (length liste) 1)
          do(if(and (string-equal type (second (nth i liste)))
                    (equal pnom NIL))
               (setf pnom (third (nth i liste)))
               (setf pnom NIL)))
    pnom))


(defun get-elem-type (gelem)
 (swm->elem-name->type gelem))


;;###############################################################;;
;;                                                               ;;
;; Internal Functions for action-move-ins()                      ;;
;;                                                               ;;
;;###############################################################;;



(defun one-by-two (cmd-splitter1 cmd-splitter2)
  ;;(format t "one by two~%") move(wood)<=(right,wood)
  (let*((desig NIL)
        (desig1 NIL)
        (desig2 NIL)
        (ref1 NIL)
        (ref2 NIL)
        (desig-intern NIL)
        (ref NIL)
        (elem1 (first (split-sequence:split-sequence #\) (second cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2)))
    (cond((and (= (length elem1-list) 1) ;;ok
               (= (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((:around ,(first (car elem1-list))))))
          (setf ref1 (reference desig-intern1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
          (setf ref2 (reference desig-intern2))           
          (setf desig1 (list 1 "" "move" ref1))
          (setf desig2 (list 1 "" "move" ref2))
          (setf desig (list desig1 desig2))) ;;done for Jon
         ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,(first (car elem1-list))))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig1 (list 1 "" "move" ref1))
          (setf desig2 (list 1 "" "move" ref2))
          (setf desig (list desig1 desig2)))
         ((and (> (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref1)(list "true" "" "move" ref2))))
      ;;    (setf desig (list "false" (format NIL "Error: There are many objects of type ~a and ~a available." elem1 elem2) "" NIL)))
         ((and (< (length elem1-list) 1)
               (= (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There is no object of type ~a available!" elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         ((and (< (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There is no object of type ~a available!" elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         ((and (= (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem1-list))))))
          (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 0 (format NIL "Error: There is no object of type ~a available!" elem2) "" NIL))))
         ((and (> (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" ref1)
                                  (list 0 (format NIL "Error: There is no object of type ~a available!" elem2) "" NIL))))
         ((and (< (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig (list (list 0 (format NIL "Error: There are no objects of type ~a and ~a available!" elem1 elem2) "" NIL))))
         (t (format t "Something went wrong in the fuction move-ins~%")
            (setf desig (list (list 0 (format NIL "Error: Something went wrong during command interpretation") "" NIL)))))
    desig))
;;;;;;;;;;;;;;;;;;;;;;;TOODO;;;;;;;;;;;;;;;;;;;;;;;;
;;move(right,wood)<=inside(right,house)
(defun two-by-two (cmd-splitter1 cmd-splitter2)
  (format t "two-by-two~%")
  (let*((elem1 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter1))))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (desig1 NIL)(desig2 NIL)(desig NIL)(desig-intern1 NIL)
        (ref1 NIL)(desig-intern2 NIL)(ref2 NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2)))
    (format t "hallooo5~%")
    (cond((and (= (length elem1-list) 1)
               (= (length elem2-list) 1))
          (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
          (format t "desig1 and desig 2 ~a ~a ~%" desig-intern1 desig-intern2)
          (setf ref1 (reference desig-intern1))(setf ref2 (reference desig-intern2))
          (setf desig1 (list 1 "" "move" ref1))(setf desig2 (list 1 "" "move" ref2))
          (format t "desig1 and desig 2 ~a ~a ~%" desig1 desig2)
          (setf desig (list desig1 desig2))) ;;done for Jon
         ((and (> (length elem1-list) 1)
               (= (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (format t "REF1 ..... ~a ~%" ref1)
          (setf desig (list (list 1 "" "move" ref1)
                            (list 1 "" "move" ref2))))
         ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (format t "REF12 ..... ~a ~%" ref1)
          (setf desig (list (list 1 "" "move" ref1)
                            (list 1 "" "move" ref2))))
         ((and (> (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf ref1 (reference desig-intern1))
          (setf desig1 (list 1 "" "move" ref1))
          (setf desig2 (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem2) "" NIL))
          (setf desig (list desig1 desig2)))
         ((and (= (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
          (setf ref1 (reference desig-intern1))
          (setf desig1 (list 1 "" "move" ref1))
          (setf desig2 (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem2) "" NIL))
          (setf desig (list desig1 desig2)))
         ((and (< (length elem1-list) 1)
               (= (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem2-list))))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem1) "" NIL) (list 1 "" "move" ref2))))
         ((and (< (length elem1-list) 1)
               (> (length elem2-list) 1))          
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem1) "" NIL) (list 1 "" "move" ref2))))
         
         ((and (> (length elem1-list) 1)
               (> (length elem2-list) 1))
	  (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (format t "REF344 ..... ~a ~%" desig-intern1)
	  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 1 "" "move" ref2))))
         ;;(setf desig (list "false" (format NIL "Error: There exist too many objects of both types in the map!") "" NIL)))
         ((and (< (length elem1-list) 1)
               (< (length elem2-list) 1))
          (format t "REF344 .....22222222~%")
          (setf desig (list (list 0 (format NIL "Error: There exist no objects of both types '~a' and '~a' in the instruction inside the map!" elem1 elem2) "" NIL))))
         (t (format t "Something went wrong during the interpretation~%")
            (setf desig (list (list 0 (format NIL "Error: Something went wrong during the command interpretation!") "" NIL)))))
    (format t "desig is ~a~%" desig)
    desig))

;;move(right,wood)<=inside(right,pointed_at(house))
(defun two-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (format t "two-by-two-point~%")
  (let*((n-gelem (instruct-mission::swm->elem-name->type gelem))
        (elem1 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter1))))))
        (elem2  (first (split-sequence::split-sequence #\) (third cmd-splitter2))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2)))
   ;; (format t "elem1 ~a~% elem2 ~a~% dir1 ~a~% dir2~a~%"elem1 elem2 dir1 dir2)
    (cond((and (= (length elem1-list) 1)
               (string-equal n-gelem elem2))
          (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,gelem))))
	  (setf ref1 (reference desig-intern1))
	  (setf ref2 (reference desig-intern2))
          (setf desig1 (list 1 "" "move" ref1))
          (setf desig2 (list 1 "" "move" ref2))
          (setf desig (list desig1 desig2))) ;;done for Jon
         ((and (= (length elem1-list) 1)
               (not (string-equal n-gelem elem2)))
          (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
          (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 0 (format NIL "Error: Pointed object ~a is not a ~a" n-gelem elem2) "" NIL))))                
         ((and (> (length elem1-list) 1)
                (string-equal n-gelem elem2))
	  (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
	  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,gelem))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig1 (list 1 "" "move" ref1))
          (setf desig2 (list 1 "" "move" ref2))
          (setf desig (list desig1 desig2))) ;;done for Jon
         ((and (> (length elem1-list) 1)
               (not (string-equal n-gelem elem2)))
	  (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf ref1 (reference desig-intern1))
          (setf desig1 (list 1 "" "move" ref1))
          (setf desig2 (list 0 (format NIL "Error: Pointed object '~a' doesn't match with NL command '~a'" n-gelem elem2) "" NIL))
          (setf desig (list desig1 desig2))) ;;done for Jon
         ((and (< (length elem1-list) 1)
                   (string-equal n-gelem elem2))
           (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,gelem))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         
         ((and (< (length elem1-list) 1)
               (not (string-equal n-gelem elem2)))
          (setf desig (list (list 0 (format NIL "Error: The Pointing Gesture couldn't be recognized!") "" NIL))))
         (t (format t "Something went wrong during the interpretation~%")
            (setf desig (list 0 (format NIL "Error: Something went wrong during the command interpretation!") "" NIL))))
    desig))

;;move(pointed_at(wood))<=inside(right,house)
(defun one-point-by-two (cmd-splitter1 cmd-splitter2 gelem)
  (format t "one-point-by-two~%")
  (let*((elem1 (first (split-sequence:split-sequence #\) (first (split-sequence:split-sequence #\, (third cmd-splitter1))))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))(desig-intern1 NIL)(desig-intern2 NIL) (ref1 NIL)(ref2 NIL)
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (desig NIL)
       ;; (desig-intern NIL)
       ;; (ref NIL)
        (type (instruct-mission::swm->elem-name->type gelem)))
    (cond((and (string-equal type elem1)
              (= (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "close") ,gelem))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 1 "" "move" ref2))))
         ((and (string-equal type elem1)
               (> (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "close") ,gelem))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 1 "" "move" ref2))))
;;          (setf desig (list "false" "Error: There are many elements available of the first" "" NIL)))
         ((and (not (string-equal type elem1))
               (= (length elem1-list) 0)
               (= (length elem2-list) 0))
          (setf desig (list (list 0 (format NIL "Error: The pointed object is of type '~a' and not a '~a'. Furthermore, '~a' does not exist inside the map!" type elem1 elem1) "" NIL))))
         ((and (not (string-equal type elem1))
               (= (length elem1-list) 1)
               (= (length elem2-list) 0))
          	  (setf desig (list (list 0 (format NIL "Error: The pointed object is of type '~a' and not a '~a'!" type elem1 elem1) "" NIL))))
         ((and (not (string-equal type elem1))
               (= (length elem1-list) 1)
               (= (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The pointed object is of type '~a' and not a '~a'!" type elem1 elem1) "" NIL)
                            (list 1 "" "move" ref2 ))))
         ((and (not (string-equal type elem1))
               (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The pointed object is of type '~a' and not a '~a'!" type elem1 elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         ((and (not (string-equal type elem1))
               (= (length elem1-list) 0)
               (= (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The pointed object is of type '~a' and not a '~a' and not available in map!" type elem1 elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         ((and (not (string-equal type elem1))
               (= (length elem1-list) 0)
               (> (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The pointed object is of type '~a' and not a '~a'!" type elem1 elem1) "" NIL)
                            (list 1 "" "move" ref2 ))))
     
         (t (format t "Something went wrong during the command interpretation~%")
            (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation of the instruction") "" NIL))))
    desig))

;;move(wood)<=inside(right,pointed(wood))
(defun one-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (format t "one-by-two-point")
  (let*((elem1 (first (split-sequence:split-sequence #\) (second cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (desig NIL)
        (desig-intern NIL)(desig-intern1 NIL)(desig-intern2 NIL)
        (ref NIL)(ref1 NIL)(ref2 NIL)
        (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->elem-name->type gelem)))
    (cond((and (string-equal type elem2)
               (= (length elem1-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,(first (car elem1-list))))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 1 "" "move" ref2))))
         ((and (string-equal type elem2)
               (> (length elem1-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 1 "" "move" ref2))))
         ((and (string-equal type elem2)
               (= (length elem1-list) 0))
           (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The command '~a' is not inside the map!" elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         ((and (not(string-equal type elem2))
               (= (length elem1-list) 0))
          (setf desig (list (list 0 (format NIL "Error: The command '~a' is not inside the map. And the pointed object '~a' is not a '~a'!" elem1 type elem2) "" NIL))))    
         ((and (not(string-equal type elem2))
               (= (length elem1-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem1-list))))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref2)
                            (list 0 (format NIL "Error: The pointed object is of type '~a' and not a '~a'. Furthermore, '~a' does not exist inside the map!" type elem2 elem2) "" NIL))))
         ((and (not(string-equal type elem2))
               (> (length elem1-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref2)
                            (list 0 (format NIL "Error: the Pointed object is of type '~a' and not a '~a'!" type elem1) "" NIL))))
         (t (format t "Something went wrong during the command interpretation~%")
            (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation of the instruction") "" NIL))))
    desig))

(defun one-point-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (type (instruct-mission::swm->elem-name->type gelem))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
      (elem1-list (instruct-mission::swm->type->amount-elems elem1))
      (elem2-list (instruct-mission::swm->type->amount-elems elem2)))  
    ;;      (elem2-list (instruct-mission::swm->type->amount-elems elem2))
    (cond((and (string-equal elem1 elem2)
               (string-equal type elem1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,gelem))))
	  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
          (setf ref1 (reference desig-intern1))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref1)
			    (list 1 "" "move" ref2))))
         ((and (string-equal elem1 elem2)
               (not (string-equal type elem1)))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
          (setf ref1 (reference desig-intern1))
          (setf desig (list (list 0 (format NIL "Error: The pointed object '~a' is not of type '~a'!" type elem1) "" NIL)
                            (list 1 "" "move" ref1))))
         ((and (not(string-equal elem1 elem2))
               (= (length elem2-list) 0))
          (setf desig (list (list 0 (format NIL "Error: You are pointing towards one object but both '~a' and '~a' objects are not of the same type" elem1 elem2) "" NIL))))
          ((and (not(string-equal elem1 elem2))
                (= (length elem2-list) 1))
           (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
           (setf ref1 (reference desig-intern1))
          (setf desig (list (list 0 (format NIL "Error: You are pointing towards one object but both '~a' and '~a' objects are not of the same type" elem1 elem2) "" NIL)
                            (list 1 "" "move" ref1)))) 
          ((and (not(string-equal elem1 elem2))
                (> (length elem2-list) 1))
           (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
           (setf ref1 (reference desig-intern1))
           (setf desig (list (list 0 (format NIL "Error: You are pointing towards one object but both '~a' and '~a' objects are not of the same type" elem1 elem2) "" NIL)
                            (list 1 "" "move" ref1)))) 
         (t (format t "Something went wrong during my command interpretation~%")
            (setf desig (list 0 (format NIL "Error: Command interpretation went wrong, please check it again!") "" NIL))))
    desig))

;;move(right,pointed(wood)<=inside(right,wood)
(defun two-point-by-two (cmd-splitter1 cmd-splitter2 gelem)
  (format t "two-point-by-two~%")
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        ;; (elem1-list (instruct-mission::swm->type->amount-elems elem1))
         (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->elem-name->type gelem)))
    (cond((and (string-equal type elem1)
               (= (length elem2-list) 1))          
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,gelem))))
	  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
	  (setf ref1 (reference desig-intern1))
	  (setf ref2 (reference desig-intern2))
	  (setf desig (list (list 1 "" "move" ref1)
			    (list 1 "" "move" ref2))))
         ((and (string-equal type elem1)
               (> (length elem2-list) 1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,gelem))))
	  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
	  (setf ref1 (reference desig-intern1))
	  (setf ref2 (reference desig-intern2))
	  (setf desig (list (list 1 "" "move" ref1)
			    (list 1 "" "move" ref2))))
         ((and (string-equal type elem1)
               (= (length elem2-list) 0))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,gelem))))
          (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 0 (format NIL "Error: There exist no object of type '~a' in the world" elem2) "" NIL))))
         ((and (not (string-equal type elem1))
               (= (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The pointing object of type '~a' is not of type '~a'!" type elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         ((and (not (string-equal type elem1))
               (> (length elem2-list) 1))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The pointing object of type '~a' is not of type '~a'!" type elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         ((and (not (string-equal type elem1))
               (< (length elem2-list) 1))
          (setf desig (list (list 0 (format NIL "Error: The pointing object of type '~a' is not of type '~a'!" type elem1) "" NIL)
                            (list 0 (format NIL "Error: The element '~a' is not given in the map" elem2) "" NIL))))
          (t (format t "something went wrong~%")
            (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation, please repeat") "" NIL))))
    desig))

;;move(right,pointed(wood))<=inside(right,pointed(wood))
(defun two-point-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
    ;;   (elem1-list (instruct-mission::swm->type->amount-elems elem1))
    ;;                (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->elem-name->type gelem)))
    (cond((and (string-equal elem1 elem2)
               (string-equal type elem1))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,gelem))))
          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,gelem))))
	  (setf ref1 (reference desig-intern1))
	  (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 1 "" "move" ref2))))
         ((and (string-equal elem1 elem2)
               (not (string-equal type elem1)))
          (setf desig (list (list 0 (format NIL "Error: the pointed object '~a' is not a '~a'!" type elem1)))))
         ((and (not(string-equal elem1 elem2))
               (string-equal type elem1)
               (not (string-equal type elem2)))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,gelem))))
          (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" ref1)
                            (list 0 (format NIL "Error: You are pointing towards one object but both '~a' is not a '~a' " elem2 elem1) "" NIL))))
         ((and (not(string-equal elem1 elem2))
               (not (string-equal type elem1))
               (string-equal type elem2))
          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,gelem))))
          (setf ref1 (reference desig-intern1))
          (setf desig (list (list 0 (format NIL "Error: You are pointing towards one object but '~a' is not a '~a'" elem2 elem1) "" NIL)
                            (list 1 "" "move" ref1))))
         ((and (not(string-equal elem1 elem2))
               (not (string-equal type elem1))
               (not (string-equal type elem2)))
          (setf desig (list (list 0 (format NIL "Error: You are pointing towards one object but both '~a' and '~a' objects are not of the same type" elem1 elem2) "" NIL))))
         (t (format t "Something went wrong during my command interpretation~%")
            (setf desig (list (list 0 (format NIL "Error: Command interpretation went wrond, please check it again!") "" NIL)))))
    desig))


(defun swm->find-elem-in-map (pose elem)
  (let*((value NIL)
        (ret NIL))
    (loop for i in '(0.5 1 1.5 2 2.5 3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 9.5 10
                     10.5 11 11.5 12 12.5 13 13.5 14 14.5 15 15.5 16 16.5 17 17.5
                     18 18.5 19 19.5 20) 
          do (if (equal ret NIL)
                 (let*((elems (swm->objects-next-human i pose))
                       (swm-liste  (swm->geopose-elements)))
                   (if (equal NIL elems)
                       (format t "")
                       (loop for jndex from 0 to (- (length elems) 1)
                             do(loop for index from 0 to (- (length swm-liste) 1)
                                     do (if (equal NIL value)
                                            (cond ((and (string-equal (first (nth index swm-liste)) (nth jndex elems))
                                                        (string-equal (second (nth index swm-liste)) elem))
                                                   (setf value T)
                                                   (setf ret (first (nth index swm-liste))))
                                                  (t ()))
                                            (format t ""))))))
                 (return)))
    ret))
