;;; Copyright (c) 2016, Fereshta Yazdani <yazdani@cs.uni-bremen.de>
;;; All rights reserved.
;; 
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions are met:
;;; 
;;;     * Redistributions of source code must retain the above copyright
;;;       notice, this list of conditions and the following disclaimer.
;;;     * Redistributions in binary form must reproduce the above copyright
;;;       notice, this list of conditions and the following disclaimer in the
;;;       documentation and/or other materials provided with the distribution.
;;;     * Neither the name of the Institute for Artificial Intelligence/
;;;       Universitaet Bremen nor the names of its contributors may be used to 
;;;       endorse or promote products derived from this software without 
;;;       specific prior written permission.
;;; 
;;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;; POSSIBILITY OF SUCH DAMAGE.

(in-package :instruct-mission)


(defun create-mhri-msg (desiglist)
  (format t "INSIDE CREAHE with desiglist : ~a~%" desiglist)
(let*((one (first desiglist))
      (boolmsg NIL)
      (errormsg NIL)
      (stringmsg NIL)
      (posemsg NIL)
      (internal NIL)
      (interpmsg NIL)
      (msg NIL))
    (format t "Length desiglist : ~a~%" (length desiglist))
  (cond ((= (length desiglist) 0)
         (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                            :data (read-from-string "false")))
         (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                          :data "Error: Why is the command empty?"))
         (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                               :value boolmsg
                                               :error errormsg
                                               :type ""
                                               :pose  (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
         (setf msg interpmsg))
        ((= (length desiglist) 1)
         (format t "ONE ACTION ~%")
         (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                            :data (read-from-string (first one))))
         (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                          :data (second one)))
         (setf stringmsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                        :data  (third one)))
         (format t "ONE ACTION2 ~%")
         (cond((equal (fourth one) NIL)
               (setf internal (cl-transforms-stamped::to-msg(cl-transforms-stamped:pose-stamped->pose (cl-transforms-stamped:make-identity-pose)))))
              (t (setf internal (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth one))))))
         (setf posemsg (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal) 'WORLD_MISSION-SRV:SUM))
         (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                               :value boolmsg
                                               :error errormsg
                                               :type stringmsg
                                               :pose posemsg))
         (setf msg (list interpmsg)))
        ((= (length desiglist) 2)
         (format t "Length desiglist : ~a~%" desiglist)
         (format t "array-msgs ~a~%" (second desiglist))
         (let*((one (first(car  desiglist)))
               (two (first (second  desiglist))))
           (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                          :data (read-from-string (first one))))
           (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                           :data (second one)))
           (setf stringmsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                            :data  (third one)))
           (format t "TESTER ~a~%" one)
           (format t "TESTER ~a~%" two)
           (cond((equal (fourth one) NIL)
                 (setf internal (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
                (t (setf internal (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth one))))))
           (setf posemsg (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal) 'WORLD_MISSION-SRV:SUM))
           (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                                 :value boolmsg
                                                 :error errormsg
                                                 :type stringmsg
                                                 :pose posemsg))
           (setf boolmsgb (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                           :data (read-from-string (first two))))
           (setf errormsgb (cl-transforms-stamped::make-msg "std_msgs/String"
                                                            :data (second two)))
           (setf stringmsgb (cl-transforms-stamped::make-msg "std_msgs/String"
                                                             :data  (third two)))
           (setf internal2  (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth two))))
           (setf posemsgb (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal2) 'WORLD_MISSION-SRV:SUM))
           (setf interpmsgb (roslisp:make-message "mhri_msgs/interpretation"
                                                  :value boolmsgb
                                                  :error errormsgb
                                                  :type stringmsgb
                                                  :pose posemsgb))
           (format t "interpmsg ~a~%" interpmsg)
           (format t "interpmsgb ~a~%" interpmsgb)  
           (setf msg (list interpmsg interpmsgb)))))
  msg))

         
(defun create-the-msg (agent type icmd gelem)
  (let*(;(gtype (get-elem-type gelem))
        (acts (split-sequence:split-sequence #\; icmd))
        (desig NIL))
    (cond ((= (length acts) 1)
           (setf desig (list (create-msg-one-action agent icmd gelem))))
          ((= (length acts) 2)
           (setf desig (create-msg-two-actions agent type icmd gelem))))
    (format t "WAS IS DEASIG ~a~%" desig)
    desig))

(defun create-msg-one-action (agent icmd gelem)
  (format t "inside create-msg-one-action~%")
  (let*((ins (split-sequence:split-sequence #\= icmd))
        (desig NIL))
    (cond ((= (length ins) 1)
           (setf desig (create-msg->action icmd gelem agent)))
          ((> (length ins) 1)
           (setf desig (create-msg->ins-actions icmd gelem))));; agent))))
     desig))

(defun create-msg-two-actions (agent type icmd gelem)
   (format t "inside create-msg-two-actions~%")
  (let*((splitter (split-sequence:split-sequence #\; icmd))
        (desig1 (create-the-msg agent type (first splitter) gelem))
        (desig2 (create-the-msg agent type (second splitter) gelem))
        (desig (list desig1 desig2)))
    (format t "TWO ACTIONS ~a~%" desig)
  desig))

;;#######################################################################################;;
;;                                                                                       ;;
;;      CREATE-MSG->INS-ACTIONS => action(direction,object)<=inside(direction,object)    ;;
;;                                                                                       ;;
;;#######################################################################################;;

(defun create-msg->ins-actions (cmd gelem);; agent)
  (let*((action (first (split-sequence:split-sequence #\( cmd)))
        (desig NIL))
    (cond ((string-equal action "move")
           (setf desig (action-move-ins cmd gelem)));; agent)))
          ((string-equal action "take")
           (setf desig (action-take-ins cmd gelem)));; agent)))
          ((string-equal action "scan")
           (setf desig (action-scan-ins cmd gelem)))
          (t (format t "Could not parse this sentence, because command is not of types: move, take or scan~%")))
    desig))


(defun action-move-ins (cmd gelem)
  (format t "hallooo~%")
(let*((cmd-split (split-sequence:split-sequence #\= cmd))
      (cmd-splitter1 (split-sequence:split-sequence #\( (first cmd-split))) 
      (cmd-splitter1-1 (split-sequence:split-sequence #\, (second cmd-splitter1))) ;;wenn move(right,wood) >= then 2 otherwise 1 <= move(wood)
      (cmd-splitter2 (split-sequence:split-sequence #\( (second cmd-split)))
      (desig NIL))
    ;;  (desig-intern NIL)
    ;;  (ref NIL))
  (cond((and (= (length cmd-splitter1) 2) ;;move(wood)
             (= (length cmd-splitter2) 2);;inside(right,wood)
             (= (length cmd-splitter1-1) 1)) ;;move(wood)
        (setf desig (one-by-two cmd-splitter1 cmd-splitter2)));; cmd-splitter1-1)))
       ((and (= (length cmd-splitter1) 2) ;;move(right,wood)
             (= (length cmd-splitter2) 2) ;;inside(right,wood)
             (= (length cmd-splitter1-1) 2)) ;;move(right,wood)
        (setf desig (two-by-two cmd-splitter1 cmd-splitter2)))
       ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
             (not (equal NIL gelem))
             (= (length cmd-splitter2) 2) ;;inside(right,wood))
             (= (length cmd-splitter1-1) 1));; move(pointed(wood)
        (setf desig (one-point-by-two cmd-splitter1 cmd-splitter2 gelem)))
       ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
             (equal NIL gelem)
             (= (length cmd-splitter2) 2) ;;inside(right,wood))
             (= (length cmd-splitter1-1) 1));; move(pointed(wood)
        (setf desig (list "false" (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL)))
         ((and (= (length cmd-splitter1) 2) ;;move(wood)
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (not (equal NIL gelem))
               (= (length cmd-splitter1-1) 1)) ;;move(wood)
          (setf desig (one-by-two-point cmd-splitter1 cmd-splitter2 gelem)))   
         ((and (= (length cmd-splitter1) 2) ;;move(wood)
               (equal NIL gelem)
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (= (length cmd-splitter1-1) 1)) ;;move(wood)
          (setf desig (list "false" (format NIL "Error: Could not calculate the pointing, please repreat!") "" NIL))) 
         ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
               (not (equal NIL gelem))
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (= (length cmd-splitter1-1) 1)) ;;move(pointed(wood))
           (setf desig (one-point-by-two-point cmd-splitter1 cmd-splitter2 gelem)))
         ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
               (equal NIL gelem)
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (= (length cmd-splitter1-1) 1)) ;;move(pointed(wood))
          (setf desig (list "false" (format NIL "Error: Could not calculate the pointing, please repreat!") "" NIL))) 
           ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                 (not (equal NIL gelem))
                 (= (length cmd-splitter2) 2) ;;move(right,wood)
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
            (setf desig (two-point-by-two cmd-splitter1 cmd-splitter2 gelem)))
             ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                   (equal NIL gelem)
                   (= (length cmd-splitter2) 2) ;;move(right,wood)
                   (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
           (setf desig (list "false" (format NIL "Error: Could not calculate the pointing, please repreat!") "" NIL)))
           ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood)
                (not (equal NIL gelem))
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
            (setf desig (two-point-by-two-point cmd-splitter1 cmd-splitter2 gelem)))
            ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood)
                (equal NIL gelem)
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
             (setf desig (list "false" (format NIL "Error: Could not calculate the pointing, please repreat!") "" NIL)))
             (t (format t "Something went wrond in the interpretation action-move-ins~%")
                (setf desig (list "false" (format NIL "Error: Something went wrong during the interpetation, please repeat your instruction") "" NIL))))
 desig)) 
    

(defun action-scan-ins (cmd gelem)
(let*((cmd-split (split-sequence:split-sequence #\= cmd))
      (cmd-counts (split-sequence:split-sequence #\( (second cmd-split)))
      (dir (first (split-sequence:split-sequence #\, (second cmd-counts))))
      (elem (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-counts))))))
      (desig NIL)
      (elem-list (instruct-mission::swm->type->amount-elems elem))
      (desig-intern NIL)
      (ref NIL))
      (cond((and (= 2 (length cmd-counts))
                 (= (length elem-list) 1))
            (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
            (setf ref (reference desig-intern))
            (setf desig (list "true" "" "scan" desig-intern ref)))
           ((and (= 2 (length cmd-counts))
                 (= (length elem-list) 0))
            (setf desig (list "false" (format NIL "Error: There is no object of type '~a' inside the map!" elem) "" NIL)))
           ((and (= 2 (length cmd-counts))
                 (> (length elem-list) 1))
            (setf desig (list "false" (format NIL "Error: There are too many objects of type '~a' inside the map!" elem) "" NIL)))
           ((and (= 3 (length cmd-counts)))
            (setf desig (action-scan-ins-pointer cmd gelem)))
           (t (format t "Something went wrong in the function action-scan-ins~%")
              (setf desig (list "false" (format NIL "Error: Something went wrong with the interpretation of the instruction!") "" NIL))))
  desig))


(defun action-scan-ins-pointer (cmd gelem)
   (let*((cmd-split (split-sequence:split-sequence #\= cmd))
         (cmd-counts (split-sequence:split-sequence #\( (second cmd-split)))
         (dir (first (split-sequence:split-sequence #\,  (second cmd-counts))))
         (elem (first (split-sequence:split-sequence #\)  (third cmd-counts))))
         (desig NIL)
         (elem-list (instruct-mission::swm->type->amount-elems elem))
         (type (instruct-mission::swm->elem-name->type gelem))
         (desig-intern NIL)
         (ref NIL))
     (cond((string-equal elem type)
           (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
          (setf ref (reference desig-intern))
           (setf desig (list "true" "" "scan" desig-intern)));;ref)))
          ((and (not(string-equal elem type))
                (/= (length elem-list) 0))
           (setf desig (list "false" (format NIL "Error: Pointed object ~a and command ~a are not fitting together" type elem) "" NIL )))
          ((and (not(string-equal elem type))
                (= (length elem-list) 0))
           (setf desig (list "false" (format NIL "Error: There is no object of type '~a' in the map!" elem) "" NIL )))
          (t (format t "Something went wrong during the interpretation in action-scan-ins-pointer")
             (setf desig (list "false" (format NIL "Something went wrong during the command interpretation!") "" NIL))))
     desig))
            
(defun action-take-ins (cmd gelem)
(let*((cmd-splitter (split-sequence:split-sequence #\= cmd))
      (cmd-splitter2 (split-sequence:split-sequence #\( (second cmd-splitter)))
                      (dir (first (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( (second cmd-splitter))))))
      (elem (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( (second cmd-splitter))))))))
      (elem-list (instruct-mission::swm->type->amount-elems elem))
      (desig NIL)
      (desig-intern NIL)
      (ref NIL))
(cond((and (= (length cmd-splitter2) 2)
           (= (length elem-list) 1))
      (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
      (setf ref (reference desig-intern))
      (setf desig (list "true" "" "take-picture" ref)))
     ((and (= (length cmd-splitter2) 2)
           (> (length elem-list) 1))
        (setf desig (list "false" (format NIL "Error: There are too many objects of type '~a'!" elem) "" NIL)))
      ((and (= (length cmd-splitter2) 2)
           (< (length elem-list) 1))
        (setf desig (list "false" (format NIL "Error: No object of type '~a' available!" elem) "" NIL)))

      ((= (length cmd-splitter2) 3)
       (setf desig (action-take-ins-pointer cmd gelem)))
      (t (format t "Something went wrong with the interpretations inside action-take-ins~%")
         (setf desig (list "false" (format NIL "Error: Could not interpret the command, not available in the vocabulary") "" NIL))))
desig))

(defun action-take-ins-pointer (cmd gelem)
(let*((cmd-splitter (split-sequence:split-sequence #\= cmd))
      (cmd-split (split-sequence:split-sequence #\(  (second cmd-splitter)))
      (elem (first (split-sequence:split-sequence #\) (third cmd-split))))
      (dir (first (split-sequence:split-sequence #\, (second cmd-split))))
      (type (instruct-mission::swm->elem-name->type gelem))
      (desig NIL)
      (desig-intern NIL)
      (ref NIL)
      (elem-list (swm->type->amount-elems elem)))
  (cond((string-equal type elem)
        (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
       (setf ref (reference desig-intern))
        (setf desig (list "true" "" "take-picture" ref)))
       ((and (not (string-equal type elem))
             (> (length elem-list) 0))
        (setf desig (list "false" (format NIL "Error: Pointed object '~a' and nl command '~a' are not the same!" type elem) "" NIL)))
        ((and (not (string-equal type elem))
             (= (length elem-list) 0))
        (setf desig (list "false" (format NIL "Error: Object in the command '~a' are not in the map!" elem) "" NIL)))
        (t (format t "Something went wrong during the interpretation in action-take-ins-pointer~%")
           (setf desig (list "false" (format NIL "Error: Could not interpret the instruction. Something is wrong.") "" NIL))))
  desig))
  


;;#######################################################################################;;
;;                                                                                       ;;
;;        CREATE-MSG-ONE-ACTION => action(direction,object) vs. action(object)           ;;
;;                                                                                       ;;
;;#######################################################################################;;

(defun create-msg->action (icmd gelem agent)
  (let*((act (first (split-sequence:split-sequence #\( icmd)))
        (desig NIL))
    (cond ((string-equal act "move")
           (setf desig (action-move icmd gelem)))
          ((string-equal act "take")
           (setf desig (action-take)))   ;;done
          ((string-equal act "scan")
           (setf desig (action-scan icmd gelem agent))) ;; done
	  ((string-equal act "come")
	   (setf desig (action-come icmd))) ;; done
          (t (format t "cmd is not of types: 'move', 'take', 'scan' and 'come'~%")
             (setf desig (list "false" (format NIL "The command couldn't be interpreted, maybe it's empty") "" NIL))))
    desig))


(defun action-come (cmd)
  (let*((fbrakets (split-sequence:split-sequence #\( cmd))
;;	(act (first fbrakets))
        (sbrakets (first (split-sequence:split-sequence #\) (second fbrakets))))
        (pose (cl-transforms:make-identity-pose)) ;;(swm->get-cartesian-pose-agent "genius"))
        (desig-intern NIL)
        (ref NIL)
        (desig NIL))
    (format t "ACTION COME~%")
    (cond ((string-equal sbrakets "back")
           (setf desig-intern (make-designator :location `((:toMe pose ))))
	   (setf ref (reference desig-intern))
	   (setf desig (list "true" "" "move" ref)))
	  (t (format t "Something went wrong inside 'action-come'~%")
	     (setf desig (list "false" (format NIL "Error: Something went wrong during the interpretation of '~a'" cmd) "" NIL))))
    desig))
	   

;;move(wood)
;;move(pointed_at(wood))
(defun action-move (cmd gelem)
  (let*((len (split-sequence:split-sequence #\, cmd))
        (fbrakets (split-sequence:split-sequence #\( cmd))
        (elem (first (split-sequence:split-sequence #\) (second fbrakets))))
        (pelem (first (split-sequence:split-sequence #\) (third fbrakets))))
        (type (instruct-mission::swm->elem-name->type gelem))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (elem-list (instruct-mission::swm->type->amount-elems elem)) ;;move(wood)
        (pelem-list (instruct-mission::swm->type->amount-elems pelem))) ;;move(pointed_at(wood))
    (cond ((and (= (length len) 1)
                (= (length fbrakets) 2)  ;;move(wood)
                (= (length elem-list) 1)) 
           (setf desig-intern (make-designator :location `((:close ,(first (car elem-list))))))
          (setf ref (reference desig-intern))
  ;;         (format t "action-move~%")
           (setf desig (list "true" "" "move" ref)))
          ((and (= (length len) 1)
                (= (length fbrakets) 2)  ;;come(back)
                (string-equal elem "back")) 
           (setf desig (action-come cmd)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 2)  ;;move(wood) to many elements TODO: move(river)
                 (> (length elem-list) 1))
            (setf desig (list "false" (format NIL "Error: There are too many objects in the world with the name '~a'" elem) "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 2)  ;;move(wood) no elements
                 (< (length elem-list) 1))
            (setf desig (list "false" (format NIL "Error: There are no objects in the world with the name '~a'" elem) "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements fits move(pointed_at(wood))
                 (not (equal gelem NIL))
                 (string-equal type pelem))
            (setf desig-intern (make-designator :location `((:close ,gelem))))
            (setf ref (reference desig-intern))
            (setf desig (list "true" "" "move" ref)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (not (string-equal type pelem))
                 (equal NIL gelem)
                 (> (length pelem-list) 0))
            (setf desig (list "false" (format NIL "Error: Not possible to recognize the pointed Object") "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (not (string-equal type pelem))
                 (not (equal NIL gelem))
                 (> (length pelem-list) 0))
            (setf desig (list "false" (format NIL "Error: Pointed Object '~a' do not fit with nl command '~a'" type pelem) "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (not (string-equal type pelem))
                 (= (length pelem-list) 0))
            (setf desig (list "false" (format NIL "Error: Pointed Object '~a' do not fit with nl command '~a' and is maybe not available in the map" type pelem) "" NIL)))
           ((and (= (length len) 2)
                 (= (length fbrakets) 3))
            (setf desig (action-move-gesture cmd gelem)))
           ((and (= (length len) 2)
                 (= (length fbrakets) 2))
            (setf desig (action-move-two cmd)))
           (t (format t "Something went wrong inside 'action-move'~%")
              (setf desig (list "false" (format NIL "Error: Something went wrong during the interpretation of '~a'" cmd) "" NIL))))
    desig))


;;move(dir,object)
(defun action-move-two (cmd)
  (format t "action-move-two~%")
  (let*((dir (first (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( cmd)))))
        (desig-intern NIL)
        (desig NIL)
        (ref NIL)
        (elem1  (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( cmd)))))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1)))
    (cond((= (length elem1-list) 1)
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem1-list))))))
    ;;      (format t "desig-intern ~a~%" desig-intern)
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((= (length elem1-list) 0)
          (setf desig (list "false" (format NIL "Error: ~a can not be found in the world" elem1) "" NIL)))
          ((> (length elem1-list) 1)
          (setf desig (list "false" (format NIL "Error: More objects of type ~a can be found in the world" elem1) "" NIL)))
          (t (format t "Something is going wrong, the interpretation did not work correctly~%")
             (setf desig (list "false" (format NIL "Error: Interpretation did not work, please repeat the command or look closer into the code") "" NIL))))
    desig))
        


;;move(dir,pointed_at(test))
(defun action-move-gesture (cmd gelem)
  (format t "action-move-gesture~%")
(let*((dir (second (split-sequence:split-sequence #\( (first (split-sequence:split-sequence #\, cmd)))))
      (desig NIL)
      (desig-intern)
      (ref NIL)
      (word (first (split-sequence:split-sequence #\) (second(split-sequence:split-sequence #\( (second (split-sequence:split-sequence #\, cmd)))))))
      (word-list (instruct-mission::swm->type->amount-elems word))
      (type (instruct-mission::swm->elem-name->type gelem)))
  ;;(format t " what is word ~a~%" word)
  (cond ((and (string-equal word type))
         (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
       (setf ref (reference desig-intern))
         (setf desig (list "true" "" "move" ref)))
        ((and (not (string-equal word type))
              (> (length word-list) 0)
              (not (equal gelem NIL)))
         (setf desig (list "false" (format NIL "Error: You are pointing towards a '~a' but you say  '~a', please correct your command!" type word )"" NIL)))
        ((and (not (string-equal word type))
              (> (length word-list) 0)
               (equal gelem NIL))
         (setf desig (list "false" (format NIL "Error: Pointing gesture not recognized, please point again!")"" NIL)))
        ((and (not (string-equal word type))
              (= 0 (length word-list)))
         (setf desig (list "false" (format NIL "Error: You are pointing towards a '~a' but you say  '~a', the '~a' is maybe not available inside the map. Please correct your command!" type word word)"" NIL)))
        (t (format t "Something went wrong inside 'action-move-gesture'~%")
           (setf desig (list "false" (format NIL "Error: Something went wrong with the interpretation of the command '~a'!" cmd) "" nil))))
  desig))

;;what we already did:
;;scan(area)/scan(pointed_at(wood)) <= area:agents-pose
;;take(picture) <=agents-pose


;;take a picture at the position of the agent
;;take(picture)
(defun action-take ()
  (let*((pose (cl-transforms:make-identity-pose)))
  (list "true" "" "take-picture" pose)))


;;scan((test))
;;scan(area) <- means wasps
(defun action-scan (icmd gelem agent)
  (let*((len (split-sequence:split-sequence #\_ icmd))
        (br (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\( icmd)))))
        (desig NIL)
        (type (instruct-mission::swm->elem-name->type gelem))
        (t-list (instruct-mission::swm->type->amount-elems br)))
    (cond((and (= (length len) 1) 
               (string-equal "area" br))
          (setf desig (list "true" "" "scan" (instruct-mission::swm->get-geopose-agent agent))))
         ((and (= (length len) 1) 
               (= (length t-list) 1)
               (string-equal br type))
          (setf desig (list "true" "" "scan" (third (first t-list)))))
         ((and (= (length len) 1) 
               (= (length t-list) 1)
               (not (string-equal br type)))
          (setf desig (list "false" (format NIL "Error: Pointed object with type '~a' is not of type '~a'."type br) "" NIL)))
         ((and (= (length len) 1) 
               (> (length t-list) 1))
          (setf desig (list "false" (format NIL "Error: Too many objects of type '~a' inside the list" br)  "" NIL)))
          ((and (= (length len) 1)
                (= (length t-list) 0))
           (setf desig (list "false" (format NIL "Error: No objects are available of type '~a'" br) "" NIL)))
          ((= (length len) 2)
           (setf desig (action-scan-with-gesture icmd gelem)))
          (t (format t "Something went wrong during command interpretation~%")
             (setf desig (list "false" "Error: Something went wrong during interpretation of '~a'" icmd))))
    desig))

;;scan(pointed_at(test))
(defun action-scan-with-gesture (cmd gelem)
(let*((elm (first (split-sequence:split-sequence #\) (third (split-sequence:split-sequence #\( cmd)))))
      (t-list (instruct-mission::swm->type->amount-elems elm))
      (n-gelem (instruct-mission::swm->elem-name->type gelem))
      (desig NIL))
  (cond ((and (= (length t-list) 1)
              (string-equal n-gelem elm))
         (setf desig (list "true" "" "scan" (instruct-mission::swm->elem-name->position gelem))))
        ((and (= (length t-list) 1)
              (not(string-equal n-gelem elm))
              (string-equal elm (second (first t-list))))
         (setf desig (list "false" (format NIL "Error: Pointed object of type '~a' is not a '~a'. Please correct your command." n-gelem elm) "" NIL)))
        ((and (=  (length t-list) 1)
              (not (string-equal elm (second (first t-list)))))
              (setf desig (list "false" (format NIL "Error: '~a' is not inside the map" elm))))
        ((> (length t-list) 1)
         (setf desig (list "false" (format NIL "Error: Two many elements in that list of type '~a'" elm) "" NIL)))
        ((= (length t-list) 0)
         (setf desig (list "false" (format NIL "Error: No object of type '~a' found in the world. Please correct your command." elm) "" NIL)))
        (t (format t "Something went wrong in 'action-scan-with-gesture'~%")
         (setf desig (list "false" (format NIL "Error: Something went wrong with command '~a'" cmd) "" NIL))))
  desig))               



;;##############################################################################;;
;;                                                                              ;;
;;                   Helping-Hands for parsing the instructions                 ;;
;;                                                                              ;;
;;##############################################################################;;


(defun swm->type->amount-elems (type)
  (let*((liste (instruct-mission::swm->geopose-elements))
        (new-liste NIL))
    (loop for index from 0 to (- (length liste) 1)
          do(cond((and (string-equal (second (nth index liste)) type)
                       (equal new-liste NIL))
                  (setf new-liste (append (list (nth index liste)) new-liste)))
                 (t ())))
    new-liste))


(defun swm->map-type->name (type)
  (let*((liste (instruct-mission::swm->geopose-elements))
        (pnom NIL))
    (loop for i from 0 to (- (length liste) 1)
          do(if(and (string-equal type (second (nth i liste)))
                    (equal pnom NIL))
               (setf pnom (third (nth i liste)))
               (setf pnom NIL)))
    pnom))


(defun get-elem-type (gelem)
 (swm->elem-name->type gelem))


;;###############################################################;;
;;                                                               ;;
;; Internal Functions for action-move-ins()                      ;;
;;                                                               ;;
;;###############################################################;;



(defun one-by-two (cmd-splitter1 cmd-splitter2)
  ;;(format t "one by two~%")
  (let*((desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (elem1 (first (split-sequence:split-sequence #\) (second cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2)))
    (cond((and (= (length elem1-list) 1) ;;ok
               (= (length elem2-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
           (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "left") ,(first (car elem1-list))))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "right") ,(first (car elem1-list))))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "in-front-of") ,(first-desig (car elem1-list))))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "behind") ,(first (car elem1-list))))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (> (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig (list "false" (format NIL "Error: There are many objects of type ~a and ~a available." elem1 elem2) "" NIL)))
         ((and (< (length elem1-list) 1)
               (>= (length elem2-list) 1))
          (setf desig (list "false" (format NIL "Error: There is no object of type ~a available!" elem1) "" NIL)))
         ((and (>= (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig (list "false" (format NIL "Error: There is no object of type ~a available!" elem2) "" NIL)))
         ((and (< (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig (list "false" (format NIL "Error: There are no objects of type ~a and ~a available!" elem1 elem2) "" NIL)))
         (t (format t "Something went wrong in the fuction move-ins~%")
            (setf desig (list "false" (format NIL "Error: Something went wrong during command interpretation") "" NIL))))))


(defun two-by-two (cmd-splitter1 cmd-splitter2)
  (let*((elem1 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter1))))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2)))
    (format t "hallooo5~%")
    (cond((and (= (length elem1-list) 1)
               (= (length elem2-list) 1)
               (not (string-equal elem1 elem2)))
          (setf desig-intern  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list)))
                                                           (,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (= (length elem1-list) 1)
               (= (length elem2-list) 1)
               (string-equal elem1 elem2))
          (setf desig (list "false" (format NIL "Error: Both types are obviously the same, please check your instruction!") "" NIL)))
         ((and (> (length elem1-list) 1)
               (= (length elem2-list) 1)
               (string-equal "right" dir2))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "left") ,(first (car elem2-list))))))
        (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (> (length elem1-list) 1)
               (= (length elem2-list) 1)
               (string-equal "left" dir2))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "right") ,(first (car elem2-list))))))
       (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (> (length elem1-list) 1)
               (= (length elem2-list) 1)
               (string-equal "behind" dir2))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "in-front-of") ,(first (car elem2-list))))))
           (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (> (length elem1-list) 1)
               (= (length elem2-list) 1)
               (string-equal "in-front-of" dir2))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "behind") ,(first (car elem2-list))))))
          ;;  (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" desig-intern)));;ref)))
         ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
         (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (>= (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig (list "false" (format NIL "Error: There exist no object of type ~a in the map!" elem2) "" NIL)))
         ((and (< (length elem1-list) 1)
               (>= (length elem2-list) 1))
          (setf desig (list "false" (format NIL "Error: There exist no object of type ~a in the map!" elem1) "" NIL)))
         ((and (> (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf desig (list "false" (format NIL "Error: There exist too many objects of both types in the map!") "" NIL)))
         ((and (< (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig (list "false" (format NIL "Error: There exist no objects of both types '~a' and '~a' in the instruction in the map!" elem1 elem2) "" NIL)))
         (t (format t "Something went wrong during the interpretation~%")
            (setf desig (list "false" (format NIL "Error: Something went wrong during the command interpretation!") "" NIL))))))


(defun one-point-by-two (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (first (split-sequence:split-sequence #\, (third cmd-splitter1))))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        ;;  (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (type (instruct-mission::swm->elem-name->type gelem)))
    (cond((and (string-equal type elem1)
               (> (length elem2-list) 0))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "close") ,gelem))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (string-equal type elem1)
               (= (length elem2-list) 0))
          (setf desig (list "false" (format NIL "Error: The command '~a' is not inside the map!" elem2) "" NIL)))                      
         ((and (not(string-equal type elem1))
               (= (length elem1-list) 0))
          (setf desig (list "false" (format NIL "Error: The pointed object is of type '~a' and not a '~a'. Furthermore, '~a' does not exist inside the map!" type elem1 elem1) "" NIL)))
         ((and (not(string-equal type elem1))
               (> (length elem1-list) 0))
          (setf desig (list "false" (format NIL "Error: The Pointed object is of type '~a' and not a '~a'!" type elem1) "" NIL)))
         (t (format t "Something went wrong during the command interpretation~%")
            (setf desig (list "false" (format NIL "Error: Something went wrong during the interpretation of the instruction") "" NIL))))))                  


(defun one-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (second cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->elem-name->type gelem)))
    (cond((and (string-equal type elem2)
               (> (length elem1-list) 0))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
   (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (string-equal type elem2)
               (= (length elem1-list) 0))
          (setf desig (list "false" (format NIL "Error: The command '~a' is not inside the map!" elem1) "" NIL)))
         ((and (not(string-equal type elem2))
               (= (length elem1-list) 0))
          (setf desig (list "false" (format NIL "Error: The command '~a' is not inside the map. And the pointed object '~a' is not a '~a'!" elem1 type elem2) "" NIL)))    
         ((and (not(string-equal type elem2))
               (= (length elem2-list) 0))
          (setf desig (list "false" (format NIL "Error: The pointed object is of type '~a' and not a '~a'. Furthermore, '~a' does not exist inside the map!" type elem2 elem2) "" NIL)))
         ((and (not(string-equal type elem1))
               (> (length elem1-list) 0))
          (setf desig (list "false" (format NIL "Error: the Pointed object is of type '~a' and not a '~a'!" type elem1) "" NIL)))
         (t (format t "Something went wrong during the command interpretation~%")
            (setf desig (list "false" (format NIL "Error: Something went wrong during the interpretation of the instruction") "" NIL))))))          

(defun one-point-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (type (instruct-mission::swm->elem-name->type gelem))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
      (elem1-list (instruct-mission::swm->type->amount-elems elem1)))
    ;;      (elem2-list (instruct-mission::swm->type->amount-elems elem2))
    (cond((and (string-equal elem1 elem2)
               (>= (length elem1-list) 1)
               (string-equal type elem1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (string-equal elem1 elem2)
               (>= (length elem1-list) 1)
               (not (string-equal type elem1)))
          (setf desig (list "false" (format NIL "Error: The pointed object '~a' is not of type '~a'!" type elem1))))
         ((and (string-equal elem1 elem2)
               (< (length elem1-list) 1))
          (setf desig (list "false" (format NIL "Error: The types are the same, but unfortunately the objects are not inside the map") "" NIL))) 
         ((not(string-equal elem1 elem2))
          (setf desig (list "false" (format NIL "Error: You are pointing towards one object but both '~a' and '~a' objects are not of the same type" elem1 elem2) "" NIL)))
         (t (format t "Something went wrong during my command interpretation~%")
            (setf desig (list "false" (format NIL "Error: Command interpretation went wrong, please check it again!") "" NIL))))))


(defun two-point-by-two (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        ;; (elem1-list (instruct-mission::swm->type->amount-elems elem1))
         (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->elem-name->type gelem)))
    (cond((and (string-equal type elem1)
               (= (length elem2-list) 1)
               (string-equal "across" dir1))
          
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "behind") ,gelem)
                                                          (,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
         (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (string-equal type elem1)
               (= (length elem2-list) 1)
               (not (string-equal "across" dir1)))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,gelem)
                                                          (,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (string-equal type elem1)
               (> (length elem2-list) 1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,gelem))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))        
         ((and (string-equal type elem1)
               (= (length elem2-list) 0))
          (setf desig (list "false" (format NIL "Error: There exist no object of type '~a' in the world" elem2))))
         ((not (string-equal type elem1))
          (setf desig (list "false" (format NIL "Error: The pointing object of type '~a' is not of type '~a'!" type elem1))))))) 


(defun two-point-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
    ;;   (elem1-list (instruct-mission::swm->type->amount-elems elem1))
    ;;                (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->elem-name->type gelem)))
    (cond((and (string-equal elem1 elem2)
               (string-equal "across" dir1)
               (string-equal type elem1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol "behind") ,gelem)
                                                          (,(instruct-mission::direction-symbol dir2) ,gelem))))
         (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move"ref)))
         ((and (string-equal elem1 elem2)
               (not (string-equal "across" dir1))
               (string-equal type elem1))
          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,gelem)
                                                          (,(instruct-mission::direction-symbol dir2) ,gelem))))
          (setf ref (reference desig-intern))
          (setf desig (list "true" "" "move" ref)))
         ((and (string-equal elem1 elem2)
               (not (string-equal type elem1)))
          (setf desig (list "false" (format NIL "Error: the pointed object '~a' is not a '~a'!" type elem1))))
         ((not(string-equal elem1 elem2))
          (setf desig (list "false" (format NIL "Error: You are pointing towards one object but both '~a' and '~a' objects are not of the same type" elem1 elem2) "" NIL)))
         (t (format t "Something went wrong during my command interpretation~%")
            (setf desig (list "false" (format NIL "Error: Command interpretation went wrond, please check it again!") "" NIL))))))
