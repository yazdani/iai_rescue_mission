;;; Copyright (c) 2016, Fereshta Yazdani <yazdani@cs.uni-bremen.de>
;;; All rights reserved.
;; 
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions are met:
;;; 
;;;     * Redistributions of source code must retain the above copyright
;;;       notice, this list of conditions and the following disclaimer.
;;;     * Redistributions in binary form must reproduce the above copyright
;;;       notice, this list of conditions and the following disclaimer in the
;;;       documentation and/or other materials provided with the distribution.
;;;     * Neither the name of the Institute for Artificial Intelligence/
;;;       Universitaet Bremen nor the names of its contributors may be used to 
;;;       endorse or promote products derived from this software without 
;;;       specific prior written permission.
;;; 
;;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;; POSSIBILITY OF SUCH DAMAGE.

(in-package :instruct-mission)


(defun create-mhri-msg (desiglist)
(format t "func(): create-mhri-msg~%")
(let*((one (first desiglist))
      (boolmsg NIL)(errormsg NIL)(stringmsg NIL)
      (posemsg NIL)(internal NIL)(interpmsg NIL)(msg NIL))
  (cond ((= (length desiglist) 0)
         (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                            :data 0))
         (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                          :data "Error: Why is the command empty?"))
         (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                               :value boolmsg
                                               :error errormsg
                                               :type ""
                                               :pose  (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
         (setf msg interpmsg))
        ((= (length desiglist) 1)
         (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                            :data (first one)))
         (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                          :data (second one)))
         (setf stringmsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                        :data  (third one)))
     
         (cond((equal (fourth one) NIL)
               (setf posemsg (cl-transforms-stamped::to-msg(cl-transforms-stamped:pose-stamped->pose (cl-transforms-stamped:make-identity-pose)))))
              (t (setf internal (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth one))))
                 (setf posemsg (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal) 'WORLD_MISSION-SRV:SUM))))
         (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                               :value boolmsg
                                               :error errormsg
                                               :type stringmsg
                                               :pose posemsg))
         (setf msg (list interpmsg)))
	((= (length desiglist) 3)
	 (setf msg (three-lists desiglist)))
        ((= (length desiglist) 2)
         (let*((one (first desiglist))
               (two (second  desiglist))
               (boolmsgb NIL)
               (errormsgb NIL)
               (stringmsgb NIL)
               (internal2 NIL)
               (posemsgb NIL)
               (interpmsgb NIL))
           (setf boolmsg (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                          :data (first one)))
           (setf errormsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                           :data (second one)))
           (setf stringmsg (cl-transforms-stamped::make-msg "std_msgs/String"
                                                            :data  (third one)))
           (cond((equal (fourth one) NIL)
                 (setf posemsg (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
                (t (setf internal (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth one))))
                   (setf posemsg (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal) 'WORLD_MISSION-SRV:SUM))))
           (setf interpmsg (roslisp:make-message "mhri_msgs/interpretation"
                                                 :value boolmsg
                                                 :error errormsg
                                                 :type stringmsg
                                                 :pose posemsg))
           (setf boolmsgb (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                           :data (first two)))
           (setf errormsgb (cl-transforms-stamped::make-msg "std_msgs/String"
                                                            :data (second two)))
           (setf stringmsgb (cl-transforms-stamped::make-msg "std_msgs/String"
                                                             :data  (third two)))
           (cond((and (or (string-equal (third one) "move")
                          (string-equal (third one) "scan"))
                      (string-equal (third two) "take-picture")
                      (equal (fourth two) NIL))
                 (setf posemsgb posemsg))
                ((and (string-equal (third one) "")
                      (string-equal (third two) "take-picture")
                       (equal (fourth two) NIL))
                 (format t "hello ~%")
                 (setf posemsgb (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
                ((and (string-equal (third two) "")
                      (not (string-equal (third two) "take-picture"))
                      (equal (fourth two) NIL))
                   (setf posemsgb (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
                (t (setf internal2 (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth two))))
                   (setf posemsgb (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal2) 'WORLD_MISSION-SRV:SUM))))
           (setf interpmsgb (roslisp:make-message "mhri_msgs/interpretation"
                                                  :value boolmsgb
                                                  :error errormsgb
                                                  :type stringmsgb
                                                  :pose posemsgb))
           (setf msg (list interpmsg interpmsgb)))))
  msg))

(defun three-lists (desiglist)
  (format t "func(): three-lists~%")
  (let*((one (first desiglist))
	(two (second  desiglist))
	(three (third desiglist))
	(boolmsga NIL)(boolmsgb NIL)(boolmsgc NIL)
	(errormsga NIL)(errormsgb NIL) (errormsgc NIL)
	(stringmsga NIL)(stringmsgb NIL)(stringmsgc NIL)
	(internal1 NIL)(internal2 NIL)(internal3 NIL)
	(posemsga NIL)(posemsgb NIL)(posemsgc NIL)(msg NIL)
	(interpmsga NIL)(interpmsgb NIL)(interpmsgc NIL))
    (setf boolmsga (cl-transforms-stamped::make-msg "std_msgs/Bool"
                                                    :data (first one)))
    (setf errormsga (cl-transforms-stamped::make-msg "std_msgs/String"
                                                     :data (second one)))
    (setf stringmsga (cl-transforms-stamped::make-msg "std_msgs/String"
                                                      :data  (third one)))
    (cond((equal (fourth one) NIL)
          (setf posemsga (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
         (t (setf internal1 (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth one))))
                   (setf posemsga (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal1) 'WORLD_MISSION-SRV:SUM))))
    (setf interpmsga (roslisp:make-message "mhri_msgs/interpretation"
                                           :value boolmsga
                                           :error errormsga
                                           :type stringmsga
                                           :pose posemsga))
    (setf boolmsgb (cl-transforms-stamped::make-msg "std_msgs/Bool"
						    :data (first two)))
    (setf errormsgb (cl-transforms-stamped::make-msg "std_msgs/String"
						     :data (second two)))
    (setf stringmsgb (cl-transforms-stamped::make-msg "std_msgs/String"
						      :data  (third two)))
   (cond((and (or (string-equal (third one) "move")
                  (string-equal (third one) "scan"))
              (string-equal (third two) "take-picture"))
         (setf posemsgb posemsga))
        ((and (not (string-equal (third one) ""))
              (string-equal (third two) "take-picture"))
         (setf posemsgb (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
        ((and (string-equal (third two) "")
              (not (string-equal (third two) "take-picture"))
                      (equal (fourth two) NIL))
                   (setf posemsgb (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
          (t (setf internal2 (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth two))))
             (setf posemsgb (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal2) 'WORLD_MISSION-SRV:SUM))))
    (setf interpmsgb (roslisp:make-message "mhri_msgs/interpretation"
                                                  :value boolmsgb
                                                  :error errormsgb
                                                  :type stringmsgb
                                                  :pose posemsgb))
    (setf boolmsgc (cl-transforms-stamped::make-msg "std_msgs/Bool"
						    :data (first three)))
    (setf errormsgc (cl-transforms-stamped::make-msg "std_msgs/String"
						     :data (second three)))
    (setf stringmsgc (cl-transforms-stamped::make-msg "std_msgs/String"
						      :data  (third three)))
    (cond((and (or (and (string-equal (third two) "move")
                        (string-equal (third one) "scan"))
                   (and (string-equal (third one) "move")
                        (string-equal (third two) "scan"))
                   (string-equal (third two) (third one))
                   (and (not(string-equal (third two) ""))
                        (string-equal (third one) "")))
               (string-equal (third three) "take-picture"))
          (setf posemsgc posemsgb))
         ((and (string-equal (third two) "")
               (not (string-equal (third one) ""))
               (string-equal (third three) "take-picture"))
          (setf posemsgc posemsga))
         ((and (not (string-equal (third three) "take-picture"))
               (equal (fourth three) NIL))
          (setf posemsgc (cl-transforms-stamped::to-msg (cl-transforms:make-identity-pose))))
         (t (setf internal3 (cl-transforms-stamped::to-msg (cl-transforms-stamped:pose-stamped->pose (fourth three))))
            (setf posemsgc (slot-value (roslisp:call-service "myned2wgs_server" 'world_mission-srv::Mywgs2ned_server :data internal3) 'WORLD_MISSION-SRV:SUM))))
    (setf interpmsgc (roslisp:make-message "mhri_msgs/interpretation"
                                                  :value boolmsgc
                                                  :error errormsgc
                                                  :type stringmsgc
                                                  :pose posemsgc))
        (setf msg (list interpmsga interpmsgb interpmsgc))
    msg))
         
(defun create-the-msg (agent type icmd gelem)
  (format t "func(): create-the-msg ~a~%" icmd)
  (let*((uno NIL)(sec NIL)(desig2 NIL)(desig3 NIL)
        (acts (split-sequence:split-sequence #\; icmd))
        (bracket (split-sequence:split-sequence #\= icmd))
        (desig NIL))
    (format t "length acts ~a~%" (length acts))
    (format t "length brackets ~a~%" (length bracket))    
    (cond ((and (= (length acts) 1)
                ( = (length bracket) 1))
           (setf desig (list (create-msg-one-action agent icmd gelem))))
          ((and ( = (length bracket) 2)
                ( = (length acts) 1))
           (setf desig (create-msg-one-action agent icmd gelem)))
          ((and (= (length acts) 2)
                (= (length bracket) 1))
           (setf desig (create-msg-two-actions agent type icmd gelem)))
          ((and (= (length bracket) 2)
                (= (length acts) 2))
           (format t "nun sind wir hier~%")
           (setf uno (remove #\( (first acts) :start 0 :end 1))
           (setf sec (format NIL "~a)" (remove #\) (second acts) :start 0)))
           (setf desig2 (list (create-msg-one-action agent uno  gelem)))
           (setf desig3 (list (create-msg-one-action agent sec gelem)))
	   (cond ((= (length desig2) 2)
            (setf desig (append desig2 desig3)))
           ((= (length desig2) 1)
            (cond((= (length (car desig2)) 4)
                  (setf desig (append desig2 desig3)))
                 ((= (length (car desig2)) 2)
                  (setf desig (append (car desig2) desig3)))))))) desig))

(defun create-msg-one-action (agent icmd gelem)
 (format t "func(): create-msg-one-action ~a~%" icmd)
  (let*((ins (split-sequence:split-sequence #\= icmd))
        (desig NIL))
    (format t "~a~%" ins)
    (format t "~a~%" (length ins))
    (cond ((= (length ins) 1)
           (setf desig (create-msg->action icmd gelem agent)))
          ((> (length ins) 1)
           (setf desig (create-msg->ins-actions icmd gelem))));; agent))))
     desig))

(defun create-msg-two-actions (agent type icmd gelem)
  (format t "func(): create-msg-two-actions~%")
  (let*((splitter (split-sequence:split-sequence #\; icmd))
        (desig1 (create-the-msg agent type (first splitter) gelem))
        (desig2 (create-the-msg agent type (second splitter) gelem))
        (desig NIL))
    (setf desig (append desig1 desig2))
    desig))

;;#######################################################################################;;
;;                                                                                       ;;
;;      CREATE-MSG->INS-ACTIONS => action(direction,object)<=inside(direction,object)    ;;
;;                                                                                       ;;
;;#######################################################################################;;

(defun create-msg->ins-actions (cmd gelem)
  (format t "func(): create-msg->ins-actions~%")
  (let*((action (first (split-sequence:split-sequence #\( cmd)))
        (desig NIL))
    (cond ((string-equal action "move")
           (setf desig (action-move-ins cmd gelem)));; agent)))
          ((string-equal action "take")
           (setf desig (action-take-ins cmd gelem)));; agent)))
      ;;    ((string-equal action "scan")
      ;;     (setf desig (action-scan-ins cmd gelem)))
          (t (format t "Could not parse this sentence, because command is not of types: move, take or scan~%")))
(format t "create-msg->ins desig ~a~%" desig)
    desig))


(defun action-move-ins (cmd gelem)
  (format t "func(): action-move-ins~%")
(let*((cmd-split (split-sequence:split-sequence #\= cmd))
      (cmd-splitter1 (split-sequence:split-sequence #\( (first cmd-split))) 
      (cmd-splitter1-1 (split-sequence:split-sequence #\, (second cmd-splitter1))) ;;wenn move(right,wood) >= then 2 otherwise 1 <= move(wood)
      (cmd-splitter2 (split-sequence:split-sequence #\( (second cmd-split)))
      (desig NIL))
  (cond((and (= (length cmd-splitter1) 2) ;;move(wood)
             (= (length cmd-splitter2) 2);;inside(right,wood)
             (= (length cmd-splitter1-1) 1)) ;;move(wood)
        (setf desig (one-by-two cmd-splitter1 cmd-splitter2)));; cmd-splitter1-1)))
       ((and (= (length cmd-splitter1) 2) ;;move(right,wood)
             (= (length cmd-splitter2) 2) ;;inside(right,wood)
             (= (length cmd-splitter1-1) 2)) ;;move(right,wood)
        (setf desig (two-by-two cmd-splitter1 cmd-splitter2)))
         ((and (= (length cmd-splitter1) 2) ;;move(right,wood)
             (= (length cmd-splitter2) 3) ;;inside(right,wood)
             (= (length cmd-splitter1-1) 2)) ;;move(right,wood)
          (setf desig (two-by-two-point cmd-splitter1 cmd-splitter2 gelem)))
       ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
             (not (equal NIL gelem))
             (= (length cmd-splitter2) 2) ;;inside(right,wood))
             (= (length cmd-splitter1-1) 1));; move(pointed(wood)
        (setf desig (one-point-by-two cmd-splitter1 cmd-splitter2 gelem)))
       ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
             (equal NIL gelem)
             (= (length cmd-splitter2) 2) ;;inside(right,wood))
             (= (length cmd-splitter1-1) 1));; move(pointed(wood)
        (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL)))
         ((and (= (length cmd-splitter1) 2) ;;move(wood)
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (not (equal NIL gelem))
               (= (length cmd-splitter1-1) 1)) ;;move(wood)
          (setf desig (one-by-two-point cmd-splitter1 cmd-splitter2 gelem)))   
         ((and (= (length cmd-splitter1) 2) ;;move(wood)
               (equal NIL gelem)
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (= (length cmd-splitter1-1) 1)) ;;move(wood)
          (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL))) 
         ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
               (not (equal NIL gelem))
               (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
               (= (length cmd-splitter1-1) 1)) ;;move(pointed(wood))
           (setf desig (one-point-by-two-point cmd-splitter1 cmd-splitter2 gelem)))
         ((and (= (length cmd-splitter1) 3) ;;move(pointed(wood))
               (equal NIL gelem))
              ;; (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood))
              ;; (= (length cmd-splitter1-1) 1)) ;;move(pointed(wood))
          (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL))) 
           ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                 (not (equal NIL gelem))
                 (= (length cmd-splitter2) 2) ;;inside(right,wood)
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
            (setf desig (two-point-by-two cmd-splitter1 cmd-splitter2 gelem)))
             ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                   (equal NIL gelem)
                   (= (length cmd-splitter2) 2) ;;move(right,wood)
                   (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
           (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL)))
           ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood)
                (not (equal NIL gelem))
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
            (setf desig (two-point-by-two-point cmd-splitter1 cmd-splitter2 gelem)))
            ((and (= (length cmd-splitter1) 3) ;;move(right,pointed(wood))
                (= (length cmd-splitter2) 3) ;;inside(right,pointed(wood)
                (equal NIL gelem)
                (= (length cmd-splitter1-1) 2)) ;;move(right,pointed(wood))
             (setf desig (list 0 (format NIL "Error: Could not calculate the pointing, please repeat!") "" NIL)))
             (t (format t "Something went wrong in the interpretation action-move-ins~%")
                (setf desig (list 0 (format NIL "Error: Something went wrong during the interpetation, please repeat your instruction") "" NIL))))
(format t "END OF FUNCTION desig ~a~%" desig)
  desig)) 


;; NO METHOD WITH POINTING GESTURE KEEP IN MIND!
;; COMMAND SCAN HAS TO BE CORRECTED
;; (defun action-scan-ins (cmd gelem)
;;   (format t "func(): action-scan-ins~%")
;; (let*((cmd-split (split-sequence:split-sequence #\= cmd))
;;       (word (first (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( cmd)))))
;;       (br (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\( cmd)))))
;;       (t-list (instruct-mission::swm->type->amount-elems br))  
;;       (cmd-counts (split-sequence:split-sequence #\( (second cmd-split)))
;;       (dir (first (split-sequence:split-sequence #\, (second cmd-counts))))
;;       (elem (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-counts))))))
;;       (desig NIL)(ref1 NIL)(ref2 NIL)
;;       (elem-list (instruct-mission::swm->type->amount-elems elem))
;;       (desig-intern1 NIL)(desig-intern NIL)(desig-intern2 NIL) (type (instruct-mission::swm->elem-name->type gelem))
;;       (ref NIL))
;;       (cond((and (= 2 (length cmd-counts))
;;                  (= (length elem-list) 1)
;;                  (= (length t-list) 1))
;;             (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car t-list))))))
;;             (setf ref1 (reference desig-intern1))
;;             (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
;;            (setf ref (reference desig-intern2))
;;             (setf desig (list (list 1 "" "scan" ref1)
;;                               (list 1 "" "scan" ref))))
;;            ((and (= 2 (length cmd-counts))
;;                  (= (length elem-list) 1)
;;                  (= (length t-list) 0))
;;             (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
;;            (setf ref (reference desig-intern2))
;;            (setf desig (list (list 0 (format NIL "Error: No object of type '~a' available inside the map" br) "" NIL)
;;                              (list 1 "" "scan" ref))))
;;            ((and (= 2 (length cmd-counts))
;;                  (= (length elem-list) 0)
;;                    (= (length t-list) 0))
;;             (setf desig (list (list 0 (format NIL "Error: There are no objects of type '~a' and '~a' inside the map!" br elem) "" NIL))))
;;            ((and (= 2 (length cmd-counts))
;;                  (= (length elem-list) 0)
;;                    (= (length t-list) 1))
;;               (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car t-list))))))
;;             (setf ref1 (reference desig-intern1))
;;             (setf desig (list (list 1 "" "scan" ref1)
;;                          (list 0 (format NIL "Error: There is no object of type '~a' inside the map!" elem) "" NIL))))
;;            ((and (= 2 (length cmd-counts))
;;                  (> (length elem-list) 1))
;;             (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem)))))
;;             (setf ref (reference desig-intern))
;;             (setf desig (list 1 "" "scan" ref)))
;;            ;; (setf desig (list "false" (format NIL "Error: There are too many objects of type '~a' inside the map!" elem) "" NIL)))
;;            ((and (= 3 (length cmd-counts)))
;;             (setf desig (action-scan-ins-pointer cmd gelem)))
;;            (t (format t "Something went wrong in the function action-scan-ins~%")
;;               (setf desig (list (list 0 (format NIL "Error: Something went wrong with the interpretation of the instruction!") "" NIL)))))
;;   desig))

;;TODO with the new function swm->get-the-right-elem
;; (defun action-scan-ins-pointer (cmd gelem)
;;   (format t "func(): action-scan-ins-pointer~%")
;;    (let*((cmd-split (split-sequence:split-sequence #\= cmd))
;;          (cmd-counts (split-sequence:split-sequence #\( (second cmd-split)))
;;          (dir (first (split-sequence:split-sequence #\,  (second cmd-counts))))
;;          (elem (first (split-sequence:split-sequence #\)  (third cmd-counts))))
;;          (desig NIL)
;;          (elem-list (instruct-mission::swm->type->amount-elems elem))
;;          (type (instruct-mission::swm->get-the-right-elem gelem elem))
;;          (desig-intern NIL)
;;          (ref NIL))
;;      (cond((not (equal type NIL))
;;            (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
;;           (setf ref (reference desig-intern))
;;            (setf desig (list 1 "" "scan" ref)))
;;           ((and (equal type NIL)
;;                 (/= (length elem-list) 0))
;;           (setf desig (list 0 (format NIL "Error: At this direction there is no object of type~a" elem) "" NIL )))
;;           ((and (equal NIL type)
;;                 (= (length elem-list) 0))
;;            (setf desig (list 0 (format NIL "Error: There is no object of type '~a' in the map!" elem) "" NIL )))
;;           (t (format t "Something went wrong during the interpretation in action-scan-ins-pointer")
;;              (setf desig (list 0 "false" (format NIL "Something went wrong during the command interpretation!") "" NIL))))
;;      (list desig)))
            
(defun action-take-ins (cmd gelem)
  (format t "func(): action-take-ins~%")
  (let*((cmd-splitter (split-sequence:split-sequence #\= cmd))
        (cmd-splitter2 (split-sequence:split-sequence #\( (second cmd-splitter)))
        (dir (first (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( (second cmd-splitter))))))
        (elem (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( (second cmd-splitter))))))))
        (elem-list (instruct-mission::swm->type->amount-elems elem))
        (desig NIL)(desig-intern NIL)(ref NIL))
(cond((and (= (length cmd-splitter2) 2)
           (= (length elem-list) 1))
         (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (third (car elem-list))))
                                                         (cl-transforms:y (cl-transforms:origin (third (car elem-list))))
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem-list)))) 10))
                                                         (cl-transforms:orientation (fifth (car elem1-list)))))         
     ; (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem-list))))))
     ; (setf ref (reference desig-intern))
      (setf desig (list 1 "" "take-picture" desig-intern1)));ref)))
     ((and (= (length cmd-splitter2) 2)
           (> (length elem-list) 1))
      (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem))
      (setf desig-intern (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                       (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))

    ;  (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem)))))
   ;   (setf ref (reference desig-intern))
      (setf desig (list 1 "" "take-picture" desig-intern)));ref)))
      ;;  (setf desig (list "false" (format NIL "Error: There are too many objects of type '~a'!" elem) "" NIL)))
      ((and (= (length cmd-splitter2) 2)
           (< (length elem-list) 1))
        (setf desig (list 0 (format NIL "Error: No object of type '~a' available!" elem) "" NIL)))
 ;;     ((= (length cmd-splitter2) 3)
 ;;      (setf desig (action-take-ins-pointer cmd gelem)))
      (t (format t "Something went wrong with the interpretations inside action-take-ins~%")
         (setf desig (list 0 (format NIL "Error: Could not interpret the command, not available in the vocabulary") "" NIL))))
desig))

;; (defun action-take-ins-pointer (cmd gelem)
;; (let*((cmd-splitter (split-sequence:split-sequence #\= cmd))
;;       (cmd-split (split-sequence:split-sequence #\(  (second cmd-splitter)))
;;       (elem (first (split-sequence:split-sequence #\) (third cmd-split))))
;;       (dir (first (split-sequence:split-sequence #\, (second cmd-split))))
;;       (type (instruct-mission::swm->get-the-right-elem gelem elem))
;;       (desig NIL)
;;       (desig-intern NIL)
;;       (ref NIL)
;;       (elem-list (swm->type->amount-elems elem)))
;;   (cond((not(equal type NIL))
;;         (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,type))))
;;        (setf ref (reference desig-intern))
;;         (setf desig (list 1 "" "take-picture" ref)))
;;        ((and (equal type NIL)
;;              (> (length elem-list) 0))
;;         (setf desig (list 0 (format NIL "Error: At this direction there is no object of type '~a'!" elem) "" NIL)))
;;         ((and (equal type NIL)
;;               (= (length elem-list) 0))
;;         (setf desig (list 0 (format NIL "Error: Object in the command '~a' is not in the map!" elem) "" NIL)))
;;         (t (format t "Something went wrong during the interpretation in action-take-ins-pointer~%")
;;            (setf desig (list 0 (format NIL "Error: Could not interpret the instruction. Something is wrong.") "" NIL))))
;;   desig))
  


;;#######################################################################################;;
;;                                                                                       ;;
;;        CREATE-MSG-ONE-ACTION => action(direction,object) vs. action(object)           ;;
;;                                                                                       ;;
;;#######################################################################################;;

(defun create-msg->action (icmd gelem agent)
  (format t "func(): create-msg->action~%")
  (format t "icmd ~a~%" icmd)
  (let*((act (first (split-sequence:split-sequence #\( icmd)))
        (desig NIL))
    (cond ((string-equal act "move")
           (setf desig (action-move icmd gelem)))
          ((string-equal act "take")
           (setf desig (action-take icmd gelem)))   ;;done
          ((string-equal act "scan")
           (setf desig (action-scan icmd gelem agent))) ;; done
	  ((string-equal act "come")
	   (setf desig (action-come icmd))) ;; done
          (t (format t "cmd is not of types: 'move', 'take', 'scan' and 'come'~%")
             (setf desig (list 0 (format NIL "The command couldn't be interpreted, maybe it's empty") "" NIL))))
    desig))


;; (defun action-come (cmd)
;;   (format t "func(): action-come~%")
;;   (let*((fbrakets (split-sequence:split-sequence #\( cmd))
;;         (sbrakets (first (split-sequence:split-sequence #\) (second fbrakets))))
;;         (pose (swm->get-cartesian-pose-agent "genius"))
;;         (desig-intern NIL)
;;         (ref NIL)
;;         (desig NIL))
;;     (cond ((string-equal sbrakets "back")
;;            (setf desig-intern (make-designator :location `((:toMe ,pose ))))
;;            (setf ref (reference desig-intern))
;; 	   (setf desig (list 1 "" "move" ref)))
;; 	  (t (format t "Something went wrong inside 'action-come'~%")
;; 	     (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation of '~a'" cmd) "" NIL))))
;;     desig))
	   

;;move(wood)
;;move(pointed_at(wood))
(defun action-move (cmd gelem)
  (format t "func(): action-move ~%")
  (let*((len (split-sequence:split-sequence #\, cmd))
        (fbrakets (split-sequence:split-sequence #\( cmd))
        (elem (first (split-sequence:split-sequence #\) (second fbrakets))))
        (pelem (first (split-sequence:split-sequence #\) (third fbrakets))))
        (desig NIL)(intern)
        (desig-intern NIL)
    ;;    (ref NIL)
        (elem-list (instruct-mission::swm->type->amount-elems elem)) ;;move(wood)
        (pelem-list (instruct-mission::swm->type->amount-elems pelem)) ;;move(pointed_at(wood))
        (type (instruct-mission::swm->get-the-right-elem gelem pelem))) 
    (cond ((and (= (length len) 1)
                (= (length fbrakets) 2)  ;;move(wood)
                (= (length elem-list) 1)) 
          ;; (setf desig-intern (make-designator :location `((:close ,(first (car elem-list))))))
         ;; (setf ref (reference desig-intern))
  ;;         (format t "action-move~%")
           (setf desig-intern (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (fifth (car elem-list))))
                                                        (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem-list)))) 15)
                                                        (cl-transforms:z (cl-transforms:origin (fifth (car elem-list)))))
                                                       (cl-transforms:orientation (fifth (car elem-list)))))                                                          
           (setf desig (list 1 "" "move" desig-intern)));;ref)))
          ((and (= (length len) 1)
                (= (length fbrakets) 2)  ;;come(back)
                (string-equal elem "back")) 
           (setf desig (action-come cmd)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 2)  ;;move(wood) to many elements TODO: move(river)
                 (> (length elem-list) 1))
            (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem))
            ;;(setf desig-intern (make-designator :location `((:close ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem)))))          
            (setf desig-intern (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
            ;; (setf desig (list "false" (format NIL "Error: There are too many objects in the world with the name '~a'" elem) "" NIL)))
           ;; (setf ref (reference desig-intern))
            (setf desig (list 1 "" "move" desig-intern)));;ref)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 2)  ;;move(wood) no elements
                 (< (length elem-list) 1))
            (setf desig (list 0 (format NIL "Error: There are no objects in the world with the name '~a'" elem) "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements fits move(pointed_at(wood))
                 (not (equal type NIL)))
            (setf desig-intern  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                      
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))));(make-designator :location `((:close ,type))))
            ;;(setf ref (reference desig-intern))
            (setf desig (list 1 "" "move" desig-intern))) ;;ref)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (equal type NIL))
            (setf desig (list 0 (format NIL "Error: At this direction there are no objects of type '~a'" pelem) "" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (equal type NIL))
            (setf desig (list "false" (format NIL "Error: At this direction there are no objects of type '~a'" pelem)"" NIL)))
           ((and (= (length len) 1)
                 (= (length fbrakets) 3)  ;;pointing with elements don-t fit move(pointed_at(wood))
                 (equal type NIL)
                 (= (length pelem-list) 0))
            (setf desig (list 0 (format NIL "Error: At this direction there are no objects of type '~a', maybe there is no element available in the map"  pelem) "" NIL)))
           ((and (= (length len) 2)
                 (= (length fbrakets) 3))
            (setf desig (action-move-gesture cmd gelem)))
           ((and (= (length len) 2)
                 (= (length fbrakets) 2))
            (setf desig (action-move-two cmd)))
           (t (format t "Something went wrong inside 'action-move'~%")
              (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation of '~a'" cmd) "" NIL))))
    desig))


;;move(dir,object)
(defun action-move-two (cmd)
  (let*(;;(dir (first (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( cmd)))))
        (desig-intern NIL)
        (desig NIL)
        (intern NIL)
        ;;(ref NIL)
        (elem1  (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second (split-sequence:split-sequence #\( cmd)))))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1)))
    (cond((= (length elem1-list) 1)
    ;;      (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem1-list))))))
    ;;      (format t "desig-intern ~a~%" desig-intern)
         ;; (setf ref (reference desig-intern))
      ;;                                                     (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
          (setf desig-intern (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                       (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                       (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                       (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                          (cl-transforms:orientation (fifth (car elem1-list)))))              
          ;;(setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem1-list))))))
            ;;                           (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)) 15))
          (setf desig (list 1 "" "move" desig-intern)))
         ((= (length elem1-list) 0)
          (setf desig (list 0 (format NIL "Error: ~a can not be found in the world" elem1) "" NIL)))
          ((> (length elem1-list) 1)
           (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
           (setf desig-intern  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                         (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                         (+(cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))10))
                                                         (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
          ;; (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          ;; (setf ref (reference desig-intern))
           (setf desig (list 1 "" "move" desig-intern)));;ref)))
          ;; (setf desig (list "false" (format NIL "Error: More objects of type ~a can be found in the world" elem1) "" NIL)))
          (t (format t "Something is going wrong, the interpretation did not work correctly~%")
             (setf desig (list 0 (format NIL "Error: Interpretation did not work, please repeat the command or look closer into the code") "" NIL))))
    desig))

;;move(dir,pointed_at(test))
(defun action-move-gesture (cmd gelem)
  ;;(;;(dir (second (split-sequence:split-sequence #\( (first (split-sequence:split-sequence #\, cmd)))))
(let*((desig NIL)
      (desig-intern)
      (word (first (split-sequence:split-sequence #\) (second(split-sequence:split-sequence #\( (second (split-sequence:split-sequence #\, cmd)))))))
      (word-list (instruct-mission::swm->type->amount-elems word))
      (type (instruct-mission::swm->get-the-right-elem gelem word)))
  (cond ((not (equal type NIL))
         (setf desig-intern  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                       (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                       (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                       (+(cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))10))
                                                      (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
  
         (setf desig (list 1 "" "move" desig-intern)));ref)))
               ;;(setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,type))))
        ;;  ;;(setf ref (reference desig-intern))
        ;; ((and (equal type NIL)
        ;;       (> (length word-list) 0)
        ;;       (not (equal type NIL)))
        ;;  (setf desig (list 0 (format NIL "Error: At this direction there exist no object of type '~a', please correct your command!" word) "" NIL)))
        ((and (equal type NIL)
              (> (length word-list) 0)
               (equal gelem NIL))
         (setf desig (list 0 (format NIL "Error: Pointing gesture not recognized, please point again!")"" NIL)))
        ((and (equal type NIL)
              (= 0 (length word-list)))
         (setf desig (list 0 (format NIL "Error: At this direction there are no objects of type '~a' available" word)"" NIL)))
        (t (format t "Something went wrong inside 'action-move-gesture'~%")
           (setf desig (list 0 (format NIL "Error: Something went wrong with the interpretation of the command '~a'!" cmd) "" nil))))
  desig))

;;what we already did:
;;scan(area)/scan(pointed_at(wood)) <= area:agents-pose
;;take(picture) <=agents-pose


;;TODO with swm->get-the-right-elem
;;take a picture at the position of the agent
;;take(picture)
(defun action-take (cmd gelem)
  (format t "func(): action-take~%")
  (let*((splitter (split-sequence:split-sequence #\, cmd))
       (brackets (split-sequence:split-sequence #\( cmd))

       (elem1 (first (split-sequence:split-sequence #\) (first (last splitter)))))
        (elem1-1 (second (split-sequence:split-sequence #\( elem1)))
        (type (instruct-mission::swm->get-the-right-elem gelem elem1))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
       (desig NIL)(desig-intern NIL) (ref NIL))
(cond ((and (= (length splitter) 1)
            (= (length brackets) 2)) ;;take(picture)
       (setf desig (list 1 "" "take-picture" NIL)))
      ((and (= (length splitter) 2)
            (= (length brackets) 2)
            (= (length elem1-list) 1));;take(picture,tree)
        (setf desig-intern  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (third (car elem1-list))))
                                                        (cl-transforms:y (cl-transforms:origin (third (car elem1-list))))
                                                       (+ (cl-transforms:z (cl-transforms:origin (third (car elem1-list))))10))
                                                       (cl-transforms:orientation (fifth (car elem1-list)))))
     ;;  (setf desig-intern (make-designator :location `((:next ,(first (car elem1-list))))))
     ;;  (setf ref (reference desig-intern))
       (setf desig (list 1 "" "take-picture" desig-intern)));;ref)))
      ((and (= (length splitter) 2)
            (= (length brackets) 2)
            (> (length elem1-list) 1));;take(picture,tree) more trees
       (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
       (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                       (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))

       (setf desig (list 1 "" "take-picture" desig-intern2)));
   ;    (setf desig-intern (make-designator :location `((:next ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))))))
      ((and (= (length splitter) 2) 
            (= (length brackets) 2)
            (< (length elem1-list) 1));;take(picture,tree) more trees
       (setf desig (list 0 (format NIL "Error: There exist no elements of type '~a' in the world" elem1) "" NIL)))
      ((and (not (equal gelem NIL))
            (not (equal gelem "")))
       (cond((and (= (length splitter) 2)
                  (= (length brackets) 3)
                  (not (equal type NIL))) ;;take(picture,pointed_at(tree))
    ;   (setf desig-intern (make-designator :location `((:next ,type))))
      ; (setf ref (reference desig-intern))
             
             (setf desig (list 1 "" "take-picture" ref)))
            ((and (= (length splitter) 2)
                  (= (length brackets) 3)
                  (equal NIL type)) ;;take(picture,pointed_at(tree))
             (setf desig (list 0 (format NIL "Error: There exist no object of type '~a' at this direction"  elem1) "" NIL)))))
      ((or (equal gelem NIL)
           (equal gelem ""))
       (format t "pointing gesture in action-take is not available~%")
       (setf desig (list 0 "Error: Could not read the pointing gesture, please repeat it" "" NIL)))           
       (t (format t "Something went wrong")
	  (setf desig (list 0 "Error: Something went wrong during command interpretation of 'take-picture'" "" NIL))))
      desig))

 


;;scan((test))
;;scan(area) <- means wasps
;; (defun action-scan (icmd gelem agent)
;;  ;; (format t "action-scan~%")
;;   (let*((test-jumper (split-sequence:split-sequence #\, icmd))
;;         (len (split-sequence:split-sequence #\_ icmd))
;;         (br (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\( icmd)))))
;;         (desig NIL)
;;         (type (instruct-mission::swm->get-the-right-elem gelem br))
;;         (t-list (instruct-mission::swm->type->amount-elems br)))
;;     (cond ((and (= (length test-jumper) 1)
;;                 (= (length len) 1))
;;            (cond((string-equal "area" br)
;;                  (setf desig (list 1 "" "scan" (instruct-mission::swm->get-cartesian-pose-agent agent))))
;;                 ((= (length t-list) 1)
;;                  (setf desig-intern2 (make-designator :location `((:around ,(first (first t-list))))))
;;                  (setf ref1 (reference desig-intern2))                 
;;                  (setf desig (list 1 "" "scan" ref1)))
;;                 ((> (length t-list) 1)
;;                  (setf desig-intern2 (make-designator :location `((:around ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") br)))))
;;                  (setf ref1 (reference desig-intern2))                 
;;                  (setf desig (list 1 "" "scan" ref1)))
;;                 ((and (= (length len) 1)
;;                       (= (length t-list) 0))
;;                  (setf desig (list 0 (format NIL "Error: No objects are available of type '~a'" br) "" NIL)))
;;                 (t (format t "Something went wrong during command interpretation~%")
;;                    (setf desig (list 0 "Error: Something went wrong during interpretation, please repeat" "" NIL)))))
;;            ((and (= (length len) 2)
;;                  (= (length test-jumper) 1))
;;             (setf desig (action-scan-with-gesture icmd gelem)))
;;            ((= (length test-jumper) 2)
;;             (setf desig (action-scan-two icmd gelem agent)))
;;            (t (format t "Something went wrong during command interpretation~%")
;;               (setf desig (list 0 "Error: Something went wrong during interpretation, please repeat" "" NIL))))
           
;;       ;;  (setf desig (action-scan-two icmd gelem agent)))
;;     desig))

;; ;;scan(right,house)
;; (defun action-scan-two (icmd gelem agent)
;;   (format t "func(): action-scan-two~%")
;;   (let*((all (split-sequence:split-sequence #\, icmd))
;;         (len (split-sequence:split-sequence #\_ icmd))
;;         (br (first (split-sequence:split-sequence #\) (second all))))
;;         (dir (second (split-sequence:split-sequence #\( (first all))))
;;         (desig NIL)
;;         (desig-intern NIL)
;;         (ref NIL)
;;         (t-list (instruct-mission::swm->type->amount-elems br)))
;;   ;;  (format t "t-list ~a~%" t-list)
;;     (cond((and (= (length len) 1) 
;;                (string-equal "area" br))
;;           (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(instruct-mission::swm->get-geopose-agent agent)))))
;;           (setf ref (reference desig-intern))
;;           (setf desig (list 1 "" "scan" ref)))
;;          ((and (= (length len) 1) 
;;                (= (length t-list) 1))
;;           (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car t-list))))))
;;           (setf ref (reference desig-intern))
;;           (setf desig (list 1 "" "scan" ref)))
;;          ((and (= (length len) 1) 
;;                (> (length t-list) 1))
;;           (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") br)))))
;;           (setf ref (reference desig-intern))
;;           (setf desig (list 1 "" "scan" ref)))
;;          ((and (= (length len) 1)
;;                (= (length t-list) 0))
;;           (setf desig (list 0 (format NIL "Error: No objects are available of type '~a'" br) "" NIL)))
;;          ((= (length len) 2)
;;           (setf desig (action-scan-with-gesture icmd gelem)))
;;          (t (format t "Something went wrong during command interpretation~%")
;;                 (setf desig (list 0 "Error: Something went wrong during interpretation of '~a'" icmd))))
;;     desig))

;; ;;TODO with swm->get-the-right-elem
;; ;;scan(pointed_at(test))
;; (defun action-scan-with-gesture (cmd gelem)
;;   (format t "func(): action-scan-with-gesture~%")
;;   (let*((test-jumper (split-sequence:split-sequence #\, cmd))
;;         (elm (first (split-sequence:split-sequence #\) (third (split-sequence:split-sequence #\( cmd)))))
;;         (t-list (instruct-mission::swm->type->amount-elems elm))
;;         (n-gelem (instruct-mission::swm->get-the-right-elem gelem elm))
;;       (desig NIL))
;;     (if (= (length test-jumper) 1)
;;         (cond ((and (= (length t-list) 1)
;;                     (not (equal n-gelem NIL)))
;;                (setf desig (list 1 "" "scan" (instruct-mission::swm->elem-name->position n-gelem))))
;;               ((and (= (length t-list) 1)
;;                     (not(string-equal n-gelem elm))
;;                     (string-equal elm (second (first t-list))))
;;                (setf desig (list 0 (format NIL "Error: Pointed object of type '~a' is not a '~a'. Please correct your command." n-gelem elm) "" NIL)))
;;               ((and (=  (length t-list) 1)
;;                     (not (string-equal elm (second (first t-list)))))
;;                (setf desig (list 0 (format NIL "Error: '~a' is not inside the map" elm))))
;;              ;; ((> (length t-list) 1)
;;              ;;  (setf desig (list "false" (format NIL "Error: Two many elements in that list of type '~a'" elm) "" NIL)))
;;               ((= (length t-list) 0)
;;                (setf desig (list 0 (format NIL "Error: No object of type '~a' found in the world. Please correct your command." elm) "" NIL)))
;;               (t (format t "Something went wrong in 'action-scan-with-gesture'~%")
;;                  (setf desig (list 0 (format NIL "Error: Something went wrong with command '~a'" cmd) "" NIL))))
;;         (setf desig (action-scan-with-gesture-two cmd gelem)))
;;   desig))               

;; ;;TODO::swm->get-the-right-elem
;; (defun action-scan-with-gesture-two (cmd gelem)
;;   ;;(format t "action-scan-with-gesture-two~%")
;; (let*((all (split-sequence:split-sequence #\, cmd))
;;      (dir (second (split-sequence:split-sequence #\( (first all))))
;;       (selm (second (split-sequence:split-sequence #\( (first (split-sequence:split-sequence #\) (second all))))))
;;       (t-list (instruct-mission::swm->type->amount-elems selm))
;;       (n-gelem (instruct-mission::swm->get-the-right-elem gelem selm))
;;       (desig NIL)
;;       (desig-intern NIL)
;;       (ref NIL))
;;   (cond ((and (= (length t-list) 1)
;;               (string-equal n-gelem selm))
;;          (setf desig-intern (make-designator :location `((,(instruct-mission::direction-symbol dir) ,gelem))))
;;          (setf ref (reference desig-intern))
;;          (setf desig (list 1 "" "scan" ref)))
;;         ((and (= (length t-list) 1)
;;               (not(string-equal n-gelem selm))
;;               (string-equal selm (second (first t-list))))
;;          (setf desig (list 0 (format NIL "Error: Pointed object of type '~a' is not a '~a'. Please correct your command." n-gelem selm) "" NIL)))
;;         ((and (=  (length t-list) 1)
;;               (not (string-equal selm (second (first t-list)))))
;;               (setf desig (list 0 (format NIL "Error: '~a' is not inside the map" selm))))
;;      ;;   ((> (length t-list) 1)
;;      ;;    (setf desig (list "false" (format NIL "Error: Two many elements in that list of type '~a'" selm) "" NIL)))
;;         ((= (length t-list) 0)
;;          (setf desig (list 0 (format NIL "Error: No object of type '~a' found in the world. Please correct your command." selm) "" NIL)))
;;         (t (format t "Something went wrong in 'action-scan-with-gesture'~%")
;;          (setf desig (list 0 (format NIL "Error: Something went wrong with command '~a'" cmd) "" NIL))))
;;   desig)) 

;;##############################################################################;;
;;                                                                              ;;
;;                   Helping-Hands for parsing the instructions                 ;;
;;                                                                              ;;
;;##############################################################################;;



(defun swm->get-the-right-elem (eliste etype)
(format t "func(): swm->get-the-right-elem~%")
  (let*((test NIL)
        (result NIL))
    (loop for index from 0 to (- (length eliste) 1)
          do(cond((and (equal test NIL)
                       (string-equal  (instruct-mission::swm->elem-name->type (nth index eliste)) etype))
                  (setf test T)
                  (setf result (nth index eliste)))
                 (t (format t "just-go-on"))))
    result))

(defun swm->type->amount-elems (type)
  (let*((liste (instruct-mission::swm->geopose-elements))
        (new-liste NIL))
    (loop for index from 0 to (- (length liste) 1)
          do (cond((and (string-equal (second (nth index liste)) type)
                       (equal new-liste NIL))
                  (setf new-liste (append (list (nth index liste)) new-liste)))
                 (t ())))
    new-liste))


(defun swm->map-type->name (type)
  (let*((liste (instruct-mission::swm->geopose-elements))
        (pnom NIL))
    (loop for i from 0 to (- (length liste) 1)
          do(if(and (string-equal type (second (nth i liste)))
                    (equal pnom NIL))
               (setf pnom (third (nth i liste)))
               (setf pnom NIL)))
    pnom))


(defun get-elem-type (gelem)
 (swm->elem-name->type gelem))


;;###############################################################;;
;;                                                               ;;
;; Internal Functions for action-move-ins()                      ;;
;;                                                               ;;
;;###############################################################;;



(defun one-by-two (cmd-splitter1 cmd-splitter2)
  ;;(format t "one by two~%") move(wood)<=(right,wood)
  (let*((desig NIL)
        (desig1 NIL)
        (desig2 NIL)
        (ref1 NIL)
        (ref2 NIL)
        (desig-intern NIL)
        (intern NIL)(intern1 NIL)(intern2 NIL)
        (ref NIL)(desig-intern1 NIL) (desig-intern2 NIL)
        (elem1 (first (split-sequence:split-sequence #\) (second cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2)))
    (cond((and (= (length elem1-list) 1) ;;ok
               (= (length elem2-list) 1))
          ;;(setf desig-intern1 (make-designator :location `((:around ,(first (car elem1-list))))))
           (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list))))10))
                                                       (cl-transforms:orientation (fifth (car elem1-list)))))
;;          (setf ref1 (reference desig-intern1))
          (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                       (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                       (cl-transforms:orientation (fifth (car elem2-list)))))
         ;; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
          ;;(setf ref2 (reference desig-intern2))           
          (setf desig1 (list 1 "" "move" desig-intern1));ref1))
          (setf desig2 (list 1 "" "move" desig-intern2));ref2))
          (setf desig (list desig1 desig2))) ;;done for Jon
         ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem1-list)))))         
           (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
     ;;     (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,(first (car elem1-list))))))
      ;    (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
        ;;  (setf ref1 (reference desig-intern1))
        ;;  (setf ref2 (reference desig-intern2))
          (setf desig1 (list 1 "" "move" desig-intern1));;ref1))
          (setf desig2 (list 1 "" "move" desig-intern2));;ref2))
          (setf desig (list desig1 desig2))) 
         ((and (> (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))
     ;;
      ;;    (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
       ;;   (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
         ;; (setf ref1 (reference desig-intern1))
         ;; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1)(list "true" "" "move" desig-intern2)))) 
      ;;    (setf desig (list "false" (format NIL "Error: There are many objects of type ~a and ~a available." elem1 elem2) "" NIL)))
         ((and (< (length elem1-list) 1)
               (= (length elem2-list) 1))
          (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))         
          
          ;;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
         ;; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There is no object of type ~a available!" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));;ref2))))
         ((and (< (length elem1-list) 1)
               (> (length elem2-list) 1))
           (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                       (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
         
          ;;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          ;;(setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There is no object of type ~a available!" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));;ref2))))
         
         ((and (= (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))         
          
          ;;(setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem1-list))))))
         ;; (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" desig-intern1);;ref1)
                            (list 0 (format NIL "Error: There is no object of type ~a available!" elem2) "" NIL))))
        
         ((and (> (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)) 
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
          ;;   (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
         ;; (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" desig-intern1);;ref1)
                            (list 0 (format NIL "Error: There is no object of type ~a available!" elem2) "" NIL)))) 
         ((and (< (length elem1-list) 1)
               (< (length elem2-list) 1))
          (setf desig (list (list 0 (format NIL "Error: There are no objects of type ~a and ~a available!" elem1 elem2) "" NIL)))) 
         (t (format t "Something went wrong in the fuction move-ins~%")
            (setf desig (list (list 0 (format NIL "Error: Something went wrong during command interpretation") "" NIL))))) 
    desig))
;;;;;;;;;;;;;;;;;;;;;;;TOODO;;;;;;;;;;;;;;;;;;;;;;;;
;;move(right,wood)<=inside(right,house)
(defun two-by-two (cmd-splitter1 cmd-splitter2)
  (format t "two-by-two ~a~% ~a~%" cmd-splitter1 cmd-splitter2)
  (let*((elem1 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter1))))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (desig1 NIL)(desig2 NIL)(desig NIL)(desig-intern1 NIL)
        (ref1 NIL)(desig-intern2 NIL)(ref2 NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2)))
    (cond((and (= (length elem1-list) 1)
               (= (length elem2-list) 1))
          ;;(setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
          ;;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
          ;;(format t "desig1 and desig 2 ~a ~a ~%" desig-intern1 desig-intern2)
          ;;(setf ref1 (reference desig-intern1))(setf ref2 (reference desig-intern2))
          
          (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem1-list)))))         
          
          (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))         
          (setf desig1 (list 1 "" "move" desig-intern1))(setf desig2 (list 1 "" "move" desig-intern2)) 
          ;;(format t "desig1 and desig 2 ~a ~a ~%" desig1 desig2)
          (setf desig (list desig1 desig2))) ;;done for Jon
        ((and (> (length elem1-list) 1)
               (= (length elem2-list) 1))
          ;;(setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          ;;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
          ;;(setf ref1 (reference desig-intern1))
          ;;(setf ref2 (reference desig-intern2))
          ;;(format t "REF1 ..... ~a ~%" ref1)
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
          (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))         
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2))));ref2))))

    ((and (= (length elem1-list) 1)
               (> (length elem2-list) 1))
         ;; (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
         ;; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
         ;; (setf ref1 (reference desig-intern1))
         ;; (setf ref2 (reference desig-intern2))
          ;; (format t "REF12 ..... ~a ~%" ref1)
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
          (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem1-list)))))         

          (setf desig (list (list 1 "" "move" desig-intern1);;ref1)
                            (list 1 "" "move" desig-intern2))));;ref2))))
         ((and (> (length elem1-list) 1)
               (< (length elem2-list) 1))
;;          (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))

          ;;(setf ref1 (reference desig-intern1))
          (setf desig1 (list 1 "" "move" desig-intern1));ref1))
          (setf desig2 (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem2) "" NIL))
          (setf desig (list desig1 desig2)))
         ((and (= (length elem1-list) 1)
               (< (length elem2-list) 1))
      ;;    (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
        ;;  (setf ref1 (reference desig-intern1))
           (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem1-list)))))         
          (setf desig1 (list 1 "" "move" desig-intern1));ref1))
          (setf desig2 (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem2) "" NIL))
          (setf desig (list desig1 desig2)))
         ((and (< (length elem1-list) 1)
               (= (length elem2-list) 1))
          (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))         
        ;;  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem2-list))))))
        ;;  (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem1) "" NIL) (list 1 "" "move" desig-intern2))));;ref2))))
         ((and (< (length elem1-list) 1)
               (> (length elem2-list) 1))          
          ;;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
  
         ;  (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem1) "" NIL) (list 1 "" "move" desig-intern2))));;ref2))))
         
         ((and (> (length elem1-list) 1)
               (> (length elem2-list) 1))
          (setf intern1 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1))) 15)
                                                       (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern1))))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                      (+  (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
  
         ;; (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
;;          (format t "REF344 ..... ~a ~%" desig-intern1)
          ;;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          ;;(setf ref1 (reference desig-intern1))
          ;;(setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2))));;ref2))))
         ;;(setf desig (list "false" (format NIL "Error: There exist too many objects of both types in the map!") "" NIL)))
         ((and (< (length elem1-list) 1)
               (< (length elem2-list) 1))
          ;;(format t "REF344 .....22222222~%")
          (setf desig (list (list 0 (format NIL "Error: There exist no objects of both types '~a' and '~a' in the instruction inside the map!" elem1 elem2) "" NIL))))
         (t (format t "Something went wrong during the interpretation~%")
            (setf desig (list (list 0 (format NIL "Error: Something went wrong during the command interpretation!") "" NIL)))))
    (format t "desig is ~a~%" desig)
    desig))

;;move(right,wood)<=inside(right,pointed_at(house))
(defun two-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (format t "two-by-two-point ~a~% ~a~% ~a~%" cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter1))))))
        (elem2  (first (split-sequence::split-sequence #\) (third cmd-splitter2))))
        (n-gelem (instruct-mission::swm->get-the-right-elem gelem elem2))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2))) 
   ;; (format t "elem1 ~a~% elem2 ~a~% dir1 ~a~% dir2~a~%"elem1 elem2 dir1 dir2)
    (cond((and (= (length elem1-list) 1)
               (not (equal n-gelem NIL))
     ;;     (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
    ;;      (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,n-gelem))))
	;;  (setf ref1 (reference desig-intern1))
	;;  (setf ref2 (reference desig-intern2))
               (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                              (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                              (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                             (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                             (cl-transforms:orientation (fifth (car elem1-list)))))
           ;    (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") n-gelem))
               (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position n-gelem)));intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position n-gelem))) 15)
                                                       (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position n-gelem))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position n-gelem))))

          (setf desig1 (list 1 "" "move" desig-intern1));ref1))
          (setf desig2 (list 1 "" "move" desig-intern2));ref2))
          (setf desig (list desig1 desig2)))) ;;done for Jon
         ((and (= (length elem1-list) 1)
               (equal n-gelem NIL))
            (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                              (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                              (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                            (+  (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                             (cl-transforms:orientation (fifth (car elem1-list)))))
        ;  (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
        ;  (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem2) "" NIL)))) 
         ((and (= (length elem1-list) 1)
               (equal n-gelem NIL))
          (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                              (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                              (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                             (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                             (cl-transforms:orientation (fifth (car elem1-list)))))
         ; (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(first (car elem1-list))))))
        ;  (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem2) "" NIL)))) 
         ((and (> (length elem1-list) 1)
                (not (equal n-gelem NIL)))
           (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
      ;    (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") n-gelem))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                       (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
       ;;   (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,n-gelem))))
       ;;   (setf ref1 (reference desig-intern1))
       ;;   (setf ref2 (reference desig-intern2))
          (setf desig1 (list 1 "" "move" desig-intern1));ref1))
          (setf desig2 (list 1 "" "move" desig-intern2));ref2))
          (setf desig (list desig1 desig2)))  ;;done for Jon
         ((and (> (length elem1-list) 1)
               (equal n-gelem NIL))
           (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
          
	 ;; (setf desig-intern1  (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
       ;;   (setf ref1 (reference desig-intern1))
          (setf desig1 (list 1 "" "move" desig-intern1));ref1))
          (setf desig2 (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem2) "" NIL))
          (setf desig (list desig1 desig2))) ;;done for Jon
         ((and (< (length elem1-list) 1)
                   (not (equal n-gelem NIL)))
           (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,n-gelem))))
       ;;   (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: There exist no object of type ~a in the map!" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (< (length elem1-list) 1)
               (equal n-gelem NIL))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem2) "" NIL))))
         (t (format t "Something went wrong during the interpretation~%")
            (setf desig (list 0 (format NIL "Error: Something went wrong during the command interpretation!") "" NIL))))
    desig))

;;move(pointed_at(wood))<=inside(right,house)
(defun one-point-by-two (cmd-splitter1 cmd-splitter2 gelem)
  (format t "one-point-by-two~%")
  (let*((elem1 (first (split-sequence:split-sequence #\) (first (split-sequence:split-sequence #\, (third cmd-splitter1))))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))(desig-intern1 NIL)(desig-intern2 NIL) (ref1 NIL)(ref2 NIL)
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (desig NIL)
       ;; (desig-intern NIL)
       ;; (ref NIL)
        (type (instruct-mission::swm->get-the-right-elem gelem elem1)))
    (cond((and (not (equal type NIL))
              (= (length elem2-list) 1))
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") type))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
         ;; (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "close") ,type))))
            (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem1-list)))))         

;          (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
 ;         (setf ref1 (reference desig-intern1))
         ;; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (not (equal type NIL))
               (> (length elem2-list) 1))
            (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") type))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
       ;;   (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "close") ,type))))
          ;;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))
         ;; (setf ref1 (reference desig-intern1))
         ;; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2))));ref2))))
;;          (setf desig (list "false" "Error: There are many elements available of the first" "" NIL)))
         ((and (equal type NIL)
               (= (length elem1-list) 0)
               (= (length elem2-list) 0))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'. Furthermore, '~a' does not exist inside the map!" elem1 elem1) "" NIL))))
         ((and (equal type NIL)
               (= (length elem1-list) 1)
               (= (length elem2-list) 0))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem2) "" NIL))))
         ((and (equal type NIL)
               (= (length elem1-list) 1)
               (= (length elem2-list) 1))
          (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+(cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))         

        ;;  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
        ;;  (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));ref2 ))))
         ((and (equal type NIL)
               (= (length elem1-list) 1)
               (> (length elem2-list) 1))
          
          ;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL)
                            (list 1 "" "move" ref2))))
         ((and (equal type NIL)
               (= (length elem1-list) 0)
               (= (length elem2-list) 1))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))
         ; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
          ;(setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The pointed object is of type '~a'is not available in map!" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (equal type NIL)
               (= (length elem1-list) 0)
               (> (length elem2-list) 1))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))
        ;  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
         ; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));ref2 ))))
         (t (format t "Something went wrong during the command interpretation~%")
            (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation of the instruction") "" NIL))))
    desig))

;;move(wood)<=inside(right,pointed(wood))
(defun one-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (format t "func(): one-by-two-point")
  (let*((elem1 (first (split-sequence:split-sequence #\) (second cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (desig NIL)
        (desig-intern NIL)(desig-intern1 NIL)(desig-intern2 NIL)
        (ref NIL)(ref1 NIL)(ref2 NIL)
        (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->get-the-right-elem gelem elem2)))
    (cond((and (not (equal type NIL))
               (= (length elem1-list) 1))
          (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem1-list)))))  
        ;  (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,(first (car elem1-list))))))
        ;  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,type))))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") type))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                        (+(cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))
       ;;   (setf ref1 (reference desig-intern1))
       ;;   (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (not (equal type NIL))
               (> (length elem1-list) 1))
          (setf intern1 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern1))))
            (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") type))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))
        ;  (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
         ; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,type))))
        ;;  (setf ref1 (reference desig-intern1))
        ;;  (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (not (equal type NIL))
               (= (length elem1-list) 0))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") type))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))
        ;   (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,type))))
         ;; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: The command '~a' is not inside the map!" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (equal NIL type)
               (= (length elem1-list) 0))
          (setf desig (list (list 0 (format NIL "Error: The command '~a' is not inside the map. And at this direction there exist no object of type '~a'!" elem1 elem2) "" NIL))))    
         ((and (equal type NIL)
               (< (length elem2-list) 1)
               (= (length elem1-list) 1))
         ; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem1-list))))))
         ; (setf ref2 (reference desig-intern2))
          (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem1-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem1-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem1-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem1-list))))) 
          (setf desig (list (list 1 "" "move" desig-intern2);ref2)
                            (list 0 (format NIL "Error: At this direction there exist no object of type '~a'. Furthermore, '~a' does not exist inside the map!" elem2 elem2) "" NIL))))
         ((and (equal NIL type)
               (> (length elem1-list) 1))
          (setf intern2 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern2))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern2))))
        ;  (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem1)))))
         ; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern2);ref2)
                            (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem2) "" NIL))))
         (t (format t "Something went wrong during the command interpretation~%")
            (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation of the instruction") "" NIL))))
    desig)) 

(defun one-point-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (type (instruct-mission::swm->get-the-right-elem gelem elem2))
        (dir (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
      (elem1-list (instruct-mission::swm->type->amount-elems elem1))
      (elem2-list (instruct-mission::swm->type->amount-elems elem2)))  
    ;;      (elem2-list (instruct-mission::swm->type->amount-elems elem2))
    (cond((and (string-equal elem1 elem2)
               (not (equal type NIL)))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
         ; (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol "around") ,type))))
         ; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir) type))))
        ;;  (setf ref1 (reference desig-intern1))
        ;;  (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2))));;ref2))))
         ((and (string-equal elem1 elem2)
               (equal type NIL))
          (setf intern1 elem2)
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern1))))                                             ;
          ;(setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,elem2))))
          ;(setf ref1 (reference desig-intern1))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem2) "" NIL)
                            (list 1 "" "move" desig-intern1))));ref1))))
         ((and (not(string-equal elem1 elem2))
               (= (length elem2-list) 0))
          (setf desig (list (list 0 (format NIL "Error: Objects are not of the same type") "" NIL))))
          ((and (not(string-equal elem1 elem2))
                (= (length elem2-list) 1))
         ;  (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(first (car elem2-list))))))
             (setf desig-intern1  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))  
           ;(setf ref1 (reference desig-intern1))
          (setf desig (list (list 0 (format NIL "Error: You are pointing towards one object but both '~a' and '~a' objects are not of the same type" elem1 elem2) "" NIL)
                            (list 1 "" "move" desig-intern1))));ref1))))
          
          ((and (not(string-equal elem1 elem2))
                (> (length elem2-list) 1))
           (setf intern1 (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern1))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern1))))
                                                        ;   (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
         ;;  (setf ref1 (reference desig-intern1))
           (setf desig (list (list 0 (format NIL "Error: Both objects are not of the same type") "" NIL)
                            (list 1 "" "move" desig-intern1))));ref1)))) 
         (t (format t "Something went wrong during my command interpretation~%")
            (setf desig (list 0 (format NIL "Error: Command interpretation went wrong, please check it again!") "" NIL))))
    desig)) 

;;move(right,pointed(wood)<=inside(right,wood)
(defun two-point-by-two (cmd-splitter1 cmd-splitter2 gelem)
  (format t "func(): two-point-by-two~%")
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (second (split-sequence:split-sequence #\, (second cmd-splitter2))))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
        ;; (elem1-list (instruct-mission::swm->type->amount-elems elem1))
        (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->get-the-right-elem gelem elem1)))
    (cond((and (not (equal type NIL))
               (= (length elem2-list) 1))          
            (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
          
           (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+(cl-transforms:z (cl-transforms:origin (fifth (car elem2-list))))10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))  
          ;;  (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,type))))
         ;; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
         ;; (setf ref1 (reference desig-intern1))
         ;; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2)))); ref2))))
         ((and (not (equal type NIL))
               (> (length elem2-list) 1))
          (setf intern (swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
            (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position intern)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position intern))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position intern))))
       ;;   (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,type))))
       ;;   (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
         ; (setf ref1 (reference desig-intern1))
         ; (setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
			    (list 1 "" "move" desig-intern2))));ref2))))
         ((and (not (equal type NIL))
               (= (length elem2-list) 0))
           (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
         ; (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,type))));gelem))))
        ;  (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 0 (format NIL "Error: There exist no object of type '~a' in the world" elem2) "" NIL))))
         ((and (equal type NIL)
               (= (length elem2-list) 1))
         ; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(first (car elem2-list))))))
           (setf desig-intern2  (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                         (cl-transforms:x (cl-transforms:origin (fifth (car elem2-list))))
                                                         (+ (cl-transforms:y (cl-transforms:origin (fifth (car elem2-list)))) 15)
                                                         (+ (cl-transforms:z (cl-transforms:origin (fifth (car elem2-list)))) 10))
                                                        (cl-transforms:orientation (fifth (car elem2-list)))))  
          
       ;   (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (equal type NIL)
               (> (length elem2-list) 1))
         ;  (setf intern (swm->find-elem-in-map (instruct-mission::swm->elem-name->position elem2)))
           (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                       (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
         ; (setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,(swm->find-elem-in-map (swm->get-cartesian-pose-agent "genius") elem2)))))
        ;  (setf ref2 (reference desig-intern2))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (equal type NIL)
               (< (length elem2-list) 1))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL)
                            (list 0 (format NIL "Error: The element '~a' is not given in the map" elem2) "" NIL))))
          (t (format t "something went wrong~%")
            (setf desig (list 0 (format NIL "Error: Something went wrong during the interpretation, please repeat") "" NIL))))
    desig))

;;move(right,pointed(wood))<=inside(right,pointed(wood))
(defun two-point-by-two-point (cmd-splitter1 cmd-splitter2 gelem)
  (let*((elem1 (first (split-sequence:split-sequence #\) (third cmd-splitter1))))
        (elem2 (first (split-sequence:split-sequence #\) (third cmd-splitter2))))
        (desig NIL)
        (desig-intern NIL)
        (ref NIL)
        (dir1 (first (split-sequence:split-sequence #\, (second cmd-splitter1))))
        (dir2 (first (split-sequence:split-sequence #\, (second cmd-splitter2))))
    ;;   (elem1-list (instruct-mission::swm->type->amount-elems elem1))
    ;;                (elem2-list (instruct-mission::swm->type->amount-elems elem2))
        (type (instruct-mission::swm->get-the-right-elem gelem elem1)))
    (cond((and (string-equal elem1 elem2)
               (not (equal type NIL)))
          (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
          (setf desig-intern2 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
          ;;(setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir1) ,type))))
          ;;(setf desig-intern2 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,type))))
          ;;(setf ref1 (reference desig-intern1))
          ;::(setf ref2 (reference desig-intern2))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 1 "" "move" desig-intern2))));ref2))))
         ((and (string-equal elem1 elem2)
               (equal NIL type))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL))))
         ((and (not(string-equal elem1 elem2))
               (not (equal type NIL))
               (not (string-equal type elem2)))
            (setf desig-intern1 (cl-transforms:make-pose (cl-transforms:make-3d-vector
                                                        (cl-transforms:x (cl-transforms:origin (instruct-mission::swm->elem-name->position type)))
                                                        (+ (cl-transforms:y (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 15)
                                                        (+ (cl-transforms:z (cl-transforms:origin (instruct-mission::swm->elem-name->position type))) 10))
                                                       (cl-transforms:orientation (instruct-mission::swm->elem-name->position type))))
         ; (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,type))))
         ; (setf ref1 (reference desig-intern1))
          (setf desig (list (list 1 "" "move" desig-intern1);ref1)
                            (list 0 (format NIL "Error: Both objects '~a' and '~a' are not the same " elem1 elem2) "" NIL) "" NIL)))
         ((and (not(string-equal elem1 elem2))
               (equal type NIL))
       ;   (setf desig-intern1 (make-designator :location `((,(instruct-mission::direction-symbol dir2) ,gelem))))
       ;   (setf ref1 (reference desig-intern1))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL)
                            (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem2) "" NIL))))
                          
         ((and (not (string-equal elem1 elem2))
               (equal type NIL))
          (setf desig (list (list 0 (format NIL "Error: At this direction there exist no object of type '~a'" elem1) "" NIL))))
         (t (format t "Something went wrong during my command interpretation~%")
            (setf desig (list (list 0 (format NIL "Error: Command interpretation went wrond, please check it again!") "" NIL)))))
    desig))


(defun swm->find-elem-in-map (pose elem)
  (format t "func(): swm->find-elem-in-map~%")
  (let*((value NIL)
        (ret NIL))
    (loop for i in '(0.5 1 1.5 2 2.5 3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 9.5 10
                     10.5 11 11.5 12 12.5 13 13.5 14 14.5 15 15.5 16 16.5 17 17.5
                     18 18.5 19 19.5 20) 
          do (if (equal ret NIL)
                 (let*((elems (swm->objects-next-human i pose))
                       (swm-liste  (swm->geopose-elements)))
                   (if (equal NIL elems)
                       (format t "")
                       (loop for jndex from 0 to (- (length elems) 1)
                             do(loop for index from 0 to (- (length swm-liste) 1)
                                     do (if (equal NIL value)
                                            (cond ((and (string-equal (first (nth index swm-liste)) (nth jndex elems))
                                                        (string-equal (second (nth index swm-liste)) elem))
                                                   (setf value T)
                                                   (setf ret (first (nth index swm-liste))))
                                                  (t ()))
                                            (format t ""))))))
                 (return)))
    ret))












